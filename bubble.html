<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>气泡自定义可视化页面</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入JSZip库用于导入导出功能 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- 🔥 统一数据库管理器 - 替代FileStorageManager -->
    <script src="utils/UnifiedDBManager.js"></script>
    <script src="utils/fontLoader.js"></script>
    <script src="utils/imageStorageAPI.js"></script>
    <script src="utils/imageDisplayHelper.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- 字体按需加载 - 移除预加载的CSS，改为动态加载 -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:6px;background:#e2e8f0;border-radius:3px;outline:none;opacity:.7;transition:opacity .2s}
        input[type="range"]:hover{opacity:1}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#4f46e5;cursor:pointer;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.2)}
        input[type="color"]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:40px;height:40px;background-color:transparent;border:none;cursor:pointer}
        input[type="color"]::-webkit-color-swatch{border-radius:50%;border:2px solid #e2e8f0}
        
        .sticker-wrapper {
            position: absolute;
            width: 120px;
            height: auto;
            cursor: grab;
            user-select: none;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .sticker-wrapper.selected {
            border: 2px dashed #4f46e5;
        }
        .sticker-wrapper.dragging {
            cursor: grabbing;
            z-index: 10000 !important;
        }
        .sticker-wrapper.inactive {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        .sticker-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain; /* 改为contain以更好地支持SVG */
        }
        
        .resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background-color: #4f46e5;
            border: 2px solid white;
            border-radius: 4px;
            cursor: se-resize;
            z-index: 1001;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        #imageEditorCanvas.dropper-cursor { cursor: crosshair; }
        #stickerLibrary { position: absolute; bottom: 1rem; left: 1rem; z-index: 500; display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(255,255,255,0.8); padding: 0.5rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(5px); max-width: 280px; }
        .library-sticker { width: 60px; height: 60px; object-fit: contain; cursor: grab; transition: transform 0.2s; }
        .library-sticker:hover { transform: scale(1.1); }

        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            opacity: 1;
        }

        .bubble-type-btn {
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            outline: none;
        }
        .bubble-type-btn:hover {
            opacity: 0.8;
        }
        
        .sticker-container {
            position: relative;
        }
    </style>
    <!-- Analytics -->
    <script defer src="https://umami.whale-llt.top/script.js" data-website-id="00c95749-7c0d-4333-9ec1-2ad2701799a3"></script>
</head>
<body class="bg-slate-100 text-slate-800">
    <!-- Toast 提示组件 -->
    <div id="toast" class="hidden fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg text-white font-medium shadow-lg transition-all duration-300"></div>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">交互式气泡样式设计器</h1>
            <p class="text-slate-500 mt-2">单击选中贴图可调整图层，双击可删除。</p>
        </header>

        <!-- 主题管理工具栏 -->
        <div class="bg-white rounded-2xl shadow-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4 items-start md:items-center justify-between">
                <div class="flex-1 max-w-md">
                    <label for="themeSelect" class="text-sm font-medium text-slate-700 mb-1 block">当前主题</label>
                    <div class="flex gap-2">
                        <select id="themeSelect" class="flex-1 text-sm border border-slate-300 rounded-lg px-3 py-2 bg-white">
                            <option value="default">默认主题</option>
                        </select>
                        <button id="createNewThemeBtn" class="bg-green-500 text-white text-sm px-3 py-2 rounded hover:bg-green-600 whitespace-nowrap">新建</button>
                        <button id="renameThemeBtn" class="bg-yellow-500 text-white text-sm px-3 py-2 rounded hover:bg-yellow-600 whitespace-nowrap">重命名</button>
                        <button id="deleteThemeBtn" class="bg-red-500 text-white text-sm px-3 py-2 rounded hover:bg-red-600 whitespace-nowrap">删除</button>
                    </div>
                </div>
                
                <div class="flex gap-2">
                    <button id="exportThemeBtn" class="bg-blue-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors text-sm">📤 导出主题</button>
                    <label for="importThemeFile" class="bg-amber-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-amber-600 transition-colors cursor-pointer text-sm">
                        📥 导入主题
                        <input type="file" id="importThemeFile" accept=".zip" class="hidden">
                    </label>
                </div>
            </div>
        </div>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-6 flex flex-col min-h-[400px] lg:min-h-[600px] overflow-hidden">
                <div class="flex-1 flex flex-col">
                    <!-- 气泡类型选择控件 -->
                    <div class="mb-4 text-center">
                        <div class="inline-flex items-center bg-slate-200 rounded-full p-1">
                            <button id="bubbleTypeSelf" class="bubble-type-btn bg-white text-indigo-600 rounded-full px-4 py-2 text-sm font-semibold">我的气泡</button>
                            <button id="bubbleTypeKare" class="bubble-type-btn text-slate-600 rounded-full px-4 py-2 text-sm font-semibold">对方气泡</button>
                        </div>
                    </div>
                    
                    <!-- 双气泡预览区域 -->
                    <div id="previewContainer" class="relative flex-1 flex flex-col justify-center space-y-4 p-4">
                        <!-- 我的气泡 -->
                        <div class="flex justify-end">
                            <div id="previewBubbleSelf" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(135, 206, 250); border-radius: 12px;">
                                <span id="bubbleTextContentSelf" style="position: relative; z-index: 10; color: rgb(255, 255, 255);">
                                    这是我发的消息
                                </span>
                                <div id="stickerLibrarySelf" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <!-- 对方气泡 -->
                        <div class="flex justify-start">
                            <div id="previewBubbleKare" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(255, 255, 255); border-radius: 12px;">
                                <span id="bubbleTextContentKare" style="position: relative; z-index: 10; color: rgb(51, 51, 51);">
                                    这是对方发的消息
                                </span>
                                <div id="stickerLibraryKare" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <div id="stickerLibrary"></div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-2xl shadow-lg p-6 space-y-6 overflow-y-auto max-h-[calc(100vh-100px)]">

                <!-- 默认主题锁定提示 -->
                <div id="defaultThemeNotice" class="hidden bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div class="ml-3">
                            <h3 class="text-sm font-medium text-yellow-800">主题被锁定</h3>
                            <p class="mt-1 text-sm text-yellow-700">默认主题不可修改。点击"新建"以创建可修改的主题。</p>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">贴纸贴图</h3>
                    <button id="manageStickersBtn" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">管理贴图库</button>
                </div>
                <div id="layerControlPanel">
                    <h3 class="font-semibold text-lg mb-3">图层顺序</h3>
                    <div class="flex gap-2">
                        <button id="sendToBackBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>置于底层</button>
                        <button id="bringToFrontBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>置于顶层</button>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">气泡基础样式</h3>
                    <div class="space-y-4">
                        <div><label for="borderWidth" class="flex justify-between text-sm font-medium text-slate-700">边框宽度 <span id="borderWidthValue">1px</span></label><input type="range" id="borderWidth" min="0" max="50" value="1" class="mt-1"></div>
                        <div><label for="borderColor" class="flex justify-between items-center text-sm font-medium text-slate-700">边框颜色 <input type="color" id="borderColor" value="#4f46e5"></label></div>
                        <div><label for="textColor" class="flex justify-between items-center text-sm font-medium text-slate-700">文本颜色 <input type="color" id="textColor" value="#333333"></label></div>
                        <div>
                            <label for="fontFamily" class="text-sm font-medium text-slate-700">字体选择</label>
                            <select id="fontFamily" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                <option value="Inter">默认字体 (Inter)</option>
                                <option value="Source Han Serif CN VF">思源宋体</option>
                                <option value="LXGW WenKai">霞鹜文楷</option>
                                <option value="Douyin Sans">抖音美好体</option>
                                <option value="Huiwen-mincho">汇文明朝体</option>
                                <option value="ToneOZ-PinyinW-Kai-Simplified">拼音鼎楷</option>
                                <option value="寒蝉全圆体 Bold">寒蝉全圆体</option>
                                <option value="峄山碑篆体">峄山碑篆体</option>
                                <option value="YuFanXinYu-Medium">余繁新语</option>
                            </select>
                        </div>
                        <div><label for="borderRadius" class="flex justify-between text-sm font-medium text-slate-700">圆角半径 <span id="borderRadiusValue">12px</span></label><input type="range" id="borderRadius" min="0" max="100" value="12" class="mt-1"></div>
                        <div class="flex items-center justify-between"><span class="text-sm font-medium text-slate-700">背景类型</span><div class="flex items-center bg-slate-200 rounded-full p-1"><button id="bgTypeSolid" class="bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold">纯色</button><button id="bgTypeGradient" class="bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold">渐变</button></div></div>
                        <div id="solidBgControls">
                             <div class="flex items-center justify-between"><label for="bgColor" class="text-sm font-medium text-slate-700">背景颜色</label><input type="color" id="bgColor" value="#ffffff"></div>
                            <div><label for="bgOpacity" class="flex justify-between text-sm font-medium text-slate-700">透明度 <span id="bgOpacityValue">100%</span></label><input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1" class="mt-1"></div>
                        </div>
                        <div id="gradientBgControls" class="hidden space-y-4">
                            <div class="flex items-center justify-between"><label for="gradientColor1" class="text-sm font-medium text-slate-700">颜色 1</label><input type="color" id="gradientColor1" value="#a5b4fc"></div>
                            <div class="flex items-center justify-between"><label for="gradientColor2" class="text-sm font-medium text-slate-700">颜色 2</label><input type="color" id="gradientColor2" value="#e0e7ff"></div>
                            <div><label for="gradientAngle" class="flex justify-between text-sm font-medium text-slate-700">渐变角度 <span id="gradientAngleValue">145deg</span></label><input type="range" id="gradientAngle" min="0" max="360" value="145" class="mt-1"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">预览内容</h3>
                    <div class="space-y-4">
                        <div><label for="bubbleText" class="text-sm font-medium text-slate-700">预览文本</label><textarea id="bubbleText" rows="3" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">这里是你的气泡预览区域。点击"管理贴图库"开始创作！</textarea></div>
                        
                        <div class="flex gap-2" id="actionButtons">
                            <button id="saveOnlyBtn" class="flex-1 bg-blue-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors">保存</button>
                            <button id="generateCodeBtn" class="flex-1 bg-emerald-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors">保存并应用</button>
                        </div>
                      </div>
                </div>
            </div>
        </main>
    </div>

    <!-- 贴图管理器 Modal -->
    <div id="imageProcessorModal" class="fixed inset-0 bg-black bg-opacity-50 z-[1000] hidden flex items-center justify-center p-4">
        <div class="w-full h-full max-w-6xl max-h-[90vh] bg-white rounded-2xl shadow-2xl flex flex-col md:flex-row">
            <div class="w-full md:w-1/3 flex flex-col border-r border-slate-200">
                <div class="p-4 border-b border-slate-200">
                    <h3 class="font-bold text-xl">贴图库</h3>
                    <p class="text-sm text-slate-500">在这里管理和编辑你的贴图。</p>
                </div>
                <div id="stickerGallery" class="flex-1 p-4 overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-4">
                </div>
                <div class="p-4 border-t border-slate-200 space-y-2">
                    <label for="galleryStickerUpload" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">上传新贴图</label>
                    <input type="file" id="galleryStickerUpload" accept="image/*" multiple class="hidden">
                    
                    <button id="toggleSvgInputBtn" class="w-full bg-purple-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-purple-700 transition-colors">输入SVG代码</button>
                    
                    <div id="svgInputSection" class="hidden space-y-2 bg-slate-50 p-3 rounded-lg border">
                        <label for="svgCodeInput" class="text-sm font-medium text-slate-700">SVG代码</label>
                        <textarea id="svgCodeInput" rows="4" class="w-full p-2 border border-slate-300 rounded text-xs font-mono" placeholder='输入SVG代码，例如：
&lt;svg width="100" height="100" viewBox="0 0 100 100"&gt;
  &lt;circle cx="50" cy="50" r="40" fill="blue" /&gt;
&lt;/svg&gt;'></textarea>
                        <div class="flex gap-2">
                            <button id="addSvgBtn" class="flex-1 bg-green-600 text-white text-sm font-medium py-1.5 px-3 rounded hover:bg-green-700 transition-colors">添加SVG</button>
                            <button id="clearSvgBtn" class="flex-1 bg-slate-500 text-white text-sm font-medium py-1.5 px-3 rounded hover:bg-slate-600 transition-colors">清空</button>
                        </div>
                    </div>
                    
                    <p class="text-xs text-slate-500 mt-2 text-center">提示：移除背景功能不支持GIF动图。请先使用外部工具处理GIF，再上传。</p>
                    <button id="closeProcessorBtn" class="w-full bg-slate-600 text-white font-medium py-2 rounded-lg hover:bg-slate-700 mt-2">完成并关闭</button>
                </div>
            </div>
            <div class="w-full md:w-2/3 flex flex-col">
                <div id="imageEditor" class="flex-1 flex items-center justify-center bg-slate-100 p-4 relative">
                    <canvas id="imageEditorCanvas" class="max-w-full max-h-full shadow-lg"></canvas>
                    <div id="editorPlaceholder" class="text-slate-500">从左侧选择一张图片进行编辑</div>
                </div>
                <div id="editorControls" class="p-4 border-t border-slate-200 bg-white space-y-4 hidden">
                    <button id="removeBgBtn" class="w-full bg-indigo-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-indigo-600">💧 移除背景</button>
                    <div>
                        <label for="tolerance" class="flex justify-between text-sm font-medium text-slate-700">容差 <span id="toleranceValue">20</span></label>
                        <input type="range" id="tolerance" min="0" max="150" value="20" class="mt-1">
                    </div>
                    <div class="flex gap-2">
                        <button id="saveChangesBtn" class="w-full bg-emerald-500 text-white font-medium py-2 rounded-lg hover:bg-emerald-600">保存更改</button>
                        <button id="resetStickerBtn" class="w-full bg-gray-500 text-white font-medium py-2 rounded-lg hover:bg-gray-600">重置图片</button>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const previewContainer = document.getElementById('previewContainer');
            const previewBubbleSelf = document.getElementById('previewBubbleSelf');
            const previewBubbleKare = document.getElementById('previewBubbleKare');
            const bubbleTextContentSelf = document.getElementById('bubbleTextContentSelf');
            const bubbleTextContentKare = document.getElementById('bubbleTextContentKare');
            const stickerLibraryContainer = document.getElementById('stickerLibrary');
            const imageProcessorModal = document.getElementById('imageProcessorModal');
            const stickerGallery = document.getElementById('stickerGallery');
            const imageEditorCanvas = document.getElementById('imageEditorCanvas');
            const editorControls = document.getElementById('editorControls');
            const editorPlaceholder = document.getElementById('editorPlaceholder');
            const ctx = imageEditorCanvas.getContext('2d');
            
            const controls = {
                manageStickersBtn: document.getElementById('manageStickersBtn'),
                closeProcessorBtn: document.getElementById('closeProcessorBtn'),
                galleryStickerUpload: document.getElementById('galleryStickerUpload'),
                toggleSvgInputBtn: document.getElementById('toggleSvgInputBtn'),
                svgInputSection: document.getElementById('svgInputSection'),
                svgCodeInput: document.getElementById('svgCodeInput'),
                addSvgBtn: document.getElementById('addSvgBtn'),
                clearSvgBtn: document.getElementById('clearSvgBtn'),
                removeBgBtn: document.getElementById('removeBgBtn'),
                tolerance: document.getElementById('tolerance'),
                toleranceValue: document.getElementById('toleranceValue'),
                saveChangesBtn: document.getElementById('saveChangesBtn'),
                resetStickerBtn: document.getElementById('resetStickerBtn'),
                sendToBackBtn: document.getElementById('sendToBackBtn'),
                bringToFrontBtn: document.getElementById('bringToFrontBtn'),
                borderWidth: document.getElementById('borderWidth'),
                borderWidthValue: document.getElementById('borderWidthValue'),
                borderColor: document.getElementById('borderColor'),
                textColor: document.getElementById('textColor'),
                fontFamily: document.getElementById('fontFamily'),
                borderRadius: document.getElementById('borderRadius'),
                borderRadiusValue: document.getElementById('borderRadiusValue'),
                bgTypeSolid: document.getElementById('bgTypeSolid'),
                bgTypeGradient: document.getElementById('bgTypeGradient'),
                solidBgControls: document.getElementById('solidBgControls'),
                gradientBgControls: document.getElementById('gradientBgControls'),
                bgColor: document.getElementById('bgColor'),
                bgOpacity: document.getElementById('bgOpacity'),
                bgOpacityValue: document.getElementById('bgOpacityValue'),
                gradientColor1: document.getElementById('gradientColor1'),
                gradientColor2: document.getElementById('gradientColor2'),
                gradientAngle: document.getElementById('gradientAngle'),
                gradientAngleValue: document.getElementById('gradientAngleValue'),
                bubbleText: document.getElementById('bubbleText'),
                defaultThemeNotice: document.getElementById('defaultThemeNotice'),
                actionButtons: document.getElementById('actionButtons'),
                saveOnlyBtn: document.getElementById('saveOnlyBtn'),
                generateCodeBtn: document.getElementById('generateCodeBtn'),
                exportThemeBtn: document.getElementById('exportThemeBtn'),
                importThemeFile: document.getElementById('importThemeFile'),
                themeSelect: document.getElementById('themeSelect'),
                createNewThemeBtn: document.getElementById('createNewThemeBtn'),
                renameThemeBtn: document.getElementById('renameThemeBtn'),
                deleteThemeBtn: document.getElementById('deleteThemeBtn'),
                bubbleTypeSelf: document.getElementById('bubbleTypeSelf'),
                bubbleTypeKare: document.getElementById('bubbleTypeKare'),
            };

            const DB_NAME = 'WhaleLLTDB';
            const DB_VERSION = 12;
            let db = null;
            let fileStorageManager = null;
            let stickerLibrary = [];
            let currentEditingStickerId = null;
            let targetColor = null;
            let currentBgType = 'solid';
            let selectedStickerWrapper = null;
            let zIndexCounter = 11;
            let currentBubbleType = 'self'; // 'self' 或 'kare'


            async function initStorageSystem() {
                try {
                    // 直接使用主应用的现有数据库连接
                    if (window.parent && window.parent.db && window.parent.isIndexedDBReady) {
                        db = window.parent.db;
                        console.log('使用主应用的现有数据库连接，版本:', db.version);
                    } else {
                        // 如果没有父窗口连接，创建独立连接
                        fileStorageManager = window.UnifiedDBManager.getInstance();
                        await fileStorageManager.init();
                        db = fileStorageManager.db;
                        console.log('创建独立数据库连接成功');
                    }
                    
                    // 如果还没有fileStorageManager，创建一个并使用现有连接
                    if (!fileStorageManager) {
                        fileStorageManager = window.UnifiedDBManager.getInstance();
                        if (db) {
                            fileStorageManager.db = db;
                            fileStorageManager.isReady = true;
                        }
                        console.log('FileStorageManager初始化成功');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('存储系统初始化失败:', error);
                    showToast('存储系统初始化失败，将使用内存存储');
                    return false;
                }
            }

            async function saveStickerLibraryToStorage() {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过保存');
                        return;
                    }
                    
                    // 使用现有数据库的 themeConfig 表保存贴图库
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 保存整个贴图库作为一个主题配置
                    const libraryData = {
                        type: 'bubbleStickers',
                        data: stickerLibrary,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(libraryData);
                    
                    transaction.oncomplete = () => {
                        console.log('贴图库保存到 themeConfig 成功');
                    };
                    
                    transaction.onerror = () => {
                        console.error('贴图库保存失败:', transaction.error);
                        showToast('保存失败：' + transaction.error.message);
                    };
                } catch (e) {
                    console.error("无法保存贴图库:", e);
                    showToast("错误：无法保存贴图库。");
                }
            }

            async function loadStickerLibraryFromStorage() {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，使用空贴图库');
                        stickerLibrary = [];
                        return;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get('bubbleStickers');
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result && result.data) {
                                stickerLibrary = result.data;
                                console.log('贴图库从 themeConfig 加载成功，共', stickerLibrary.length, '个贴图');
                            } else {
                                stickerLibrary = [];
                                console.log('未找到已保存的贴图库，使用空库');
                            }
                            resolve();
                        };
                        
                        request.onerror = () => {
                            console.error('加载贴图库失败:', request.error);
                            stickerLibrary = [];
                            resolve(); // 即使失败也要继续
                        };
                    });
                } catch (e) {
                    console.error("无法加载贴图库:", e);
                    stickerLibrary = [];
                }
            }

            function updateBubbleStyle() {
                const borderWidth = controls.borderWidth.value;
                const borderRadius = controls.borderRadius.value;
                
                // 获取当前编辑的气泡元素
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                
                console.log(`updateBubbleStyle: currentBgType=${currentBgType}, bubbleType=${currentBubbleType}`);
                
                // 清理之前的背景样式，避免样式冲突
                currentBubble.style.background = '';
                currentBubble.style.backgroundColor = '';
                
                currentBubble.style.borderWidth = `${borderWidth}px`;
                currentBubble.style.borderColor = controls.borderColor.value;
                currentBubble.style.borderRadius = `${borderRadius}px`;
                
                // 更新文本颜色
                currentTextContent.style.color = controls.textColor.value;
                
                // 更新字体
                const selectedFont = controls.fontFamily.value;
                currentTextContent.style.fontFamily = selectedFont;
                
                // 动态加载字体（如果需要）
                if (window.fontLoader && selectedFont && selectedFont !== 'Inter') {
                    window.fontLoader.loadFont(selectedFont).then(success => {
                        if (success) {
                            console.log(`字体加载成功，应用到预览: ${selectedFont}`);
                        } else {
                            console.warn(`字体加载失败: ${selectedFont}`);
                        }
                    }).catch(error => {
                        console.error(`字体加载异常: ${selectedFont}`, error);
                    });
                }

                if (currentBgType === 'solid') {
                    const color = controls.bgColor.value;
                    const opacity = controls.bgOpacity.value;
                    const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16);
                    currentBubble.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    console.log(`应用纯色背景: rgba(${r}, ${g}, ${b}, ${opacity})`);
                } else {
                    const color1 = controls.gradientColor1.value, color2 = controls.gradientColor2.value, angle = controls.gradientAngle.value;
                    currentBubble.style.background = `linear-gradient(${angle}deg, ${color1}, ${color2})`;
                    console.log(`应用渐变背景: linear-gradient(${angle}deg, ${color1}, ${color2})`);
                }
                controls.borderWidthValue.textContent = `${borderWidth}px`;
                controls.borderRadiusValue.textContent = `${borderRadius}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
            }

            // 获取当前气泡类型
            function getCurrentBubbleType() {
                return currentBubbleType || 'self';
            }

            // 更新所有贴纸的交互状态
            function updateStickersInteractionState() {
                // 更新自己气泡中的贴纸状态
                previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'self') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });

                // 更新对方气泡中的贴纸状态
                previewBubbleKare.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'kare') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });
            }

            // 切换气泡类型
            async function switchBubbleType(type) {
                const oldType = currentBubbleType;
                
                // 保存当前UI状态到缓存（在切换之前）
                // 但如果当前是默认主题，不保存状态到缓存，因为默认主题是只读的
                if (oldType && currentThemeName !== 'default') {
                    uiStateCache[oldType] = captureCurrentUIState();
                    console.log(`已保存${oldType}的UI状态到缓存`);
                } else if (oldType && currentThemeName === 'default') {
                    console.log(`跳过保存默认主题的UI状态到缓存（默认主题是只读的）`);
                }
                
                currentBubbleType = type;
                
                // 更新按钮状态
                if (type === 'self') {
                    controls.bubbleTypeSelf.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.remove('text-slate-600');
                    controls.bubbleTypeKare.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeKare.classList.add('text-slate-600');
                } else {
                    controls.bubbleTypeKare.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeKare.classList.remove('text-slate-600');
                    controls.bubbleTypeSelf.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.add('text-slate-600');
                }
                
                // 根据当前主题加载UI状态
                if (currentThemeName === 'default') {
                    // 默认主题：始终使用固定的默认配置
                    const defaultConfig = DEFAULT_THEME_CONFIG[type];
                    console.log(`加载默认主题的${type}配置`);
                    await applyConfigToUI(type, defaultConfig);
                } else if (uiStateCache[type]) {
                    console.log(`从缓存加载${type}的UI状态`);
                    applyUIState(uiStateCache[type]);
                } else {
                    console.log(`缓存中没有${type}的状态，从数据库加载`);
                    await loadBubbleTypeSettings(type);
                    // 加载后立即缓存
                    uiStateCache[type] = captureCurrentUIState();
                }
                
                // 更新预览样式
                updateBubbleStyle();
                
                // 更新贴纸交互状态
                updateStickersInteractionState();
                
                showToast(`已切换到${type === 'self' ? '我的气泡' : '对方气泡'}编辑模式`);
            }

            // 加载指定气泡类型的设置
            async function loadBubbleTypeSettings(type) {
                const targetBubble = type === 'self' ? previewBubbleSelf : previewBubbleKare;
                const targetTextContent = type === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                
                // 首先尝试从保存的配置中加载
                const styleKey = type === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
                const savedConfig = await loadBubbleStyleConfig(styleKey);
                
                if (savedConfig) {
                    // 如果有保存的配置，应用到控件
                    console.log(`加载${type === 'self' ? '我的' : '对方的'}气泡保存配置`);
                    
                    // 应用基础样式到控件
                    controls.borderWidth.value = savedConfig.borderWidth || 1;
                    controls.borderColor.value = extractRgbColor(savedConfig.borderColor) || '#4f46e5';
                    controls.borderRadius.value = savedConfig.borderRadius || 12;
                    controls.textColor.value = extractRgbColor(savedConfig.textColor) || '#333333';
                    controls.fontFamily.value = savedConfig.fontFamily || 'Inter';
                    
                    // 应用背景样式到控件
                    currentBgType = savedConfig.backgroundType || 'solid';
                    controls.bgColor.value = extractRgbColor(savedConfig.backgroundColor) || '#ffffff';
                    controls.bgOpacity.value = savedConfig.backgroundOpacity || 1;
                    controls.gradientColor1.value = extractRgbColor(savedConfig.gradientColor1) || '#a5b4fc';
                    controls.gradientColor2.value = extractRgbColor(savedConfig.gradientColor2) || '#e0e7ff';
                    controls.gradientAngle.value = savedConfig.gradientAngle || 145;
                    
                    // 切换背景类型UI
                    console.log(`加载${type}气泡配置: 背景类型=${currentBgType}, 渐变色1=${controls.gradientColor1.value}, 渐变色2=${controls.gradientColor2.value}`);
                    
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.checked = true;
                        controls.bgTypeSolid.checked = false;
                        // 使用CSS类控制显示/隐藏，而不是style属性
                        controls.solidBgControls.classList.add('hidden');
                        controls.gradientBgControls.classList.remove('hidden');
                        // 同时更新按钮样式
                        controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    } else {
                        controls.bgTypeSolid.checked = true;
                        controls.bgTypeGradient.checked = false;
                        // 使用CSS类控制显示/隐藏
                        controls.solidBgControls.classList.remove('hidden');
                        controls.gradientBgControls.classList.add('hidden');
                        // 同时更新按钮样式
                        controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    }
                    
                    // 文本内容始终使用默认值，不从配置中加载
                    const defaultText = type === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                    
                    // 更新值显示标签
                    controls.borderWidthValue.textContent = `${controls.borderWidth.value}px`;
                    controls.borderRadiusValue.textContent = `${controls.borderRadius.value}px`;
                    controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                    controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
                    
                    // 确保全局变量与UI控件状态同步
                    currentBgType = savedConfig.backgroundType || 'solid';
                    console.log(`${type}气泡配置应用完成: currentBgType=${currentBgType}`);
                    
                } else {
                    // 如果没有保存的配置，使用默认值
                    console.log(`使用${type === 'self' ? '我的' : '对方的'}气泡默认配置`);
                    
                    // 设置默认值
                    controls.borderWidth.value = 1;
                    controls.borderColor.value = '#4f46e5';
                    controls.borderRadius.value = 12;
                    controls.textColor.value = type === 'self' ? '#ffffff' : '#333333';
                    controls.fontFamily.value = 'Inter';
                    
                    currentBgType = 'solid';
                    controls.bgColor.value = type === 'self' ? '#87CEEB' : '#ffffff';
                    controls.bgOpacity.value = 1;
                    controls.gradientColor1.value = '#a5b4fc';
                    controls.gradientColor2.value = '#e0e7ff';
                    controls.gradientAngle.value = 145;
                    
                    controls.bgTypeSolid.click();
                    
                    // 文本内容始终使用默认值
                    const defaultText = type === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                }
                
                // 更新样式显示
                updateBubbleStyle();
                
                console.log(`${type}气泡配置加载完成，UI控件已更新`);
            }

            function openProcessor() { 
                imageProcessorModal.style.display = 'flex'; 
                populateStickerGallery().catch(error => console.error('填充贴图库失败:', error)); 
            }
            function closeProcessor() { 
                imageProcessorModal.style.display = 'none'; 
                renderStickerLibrary().catch(error => console.error('渲染贴图库失败:', error)); 
            }

            async function handleStickerUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                try {
                    showToast('正在上传贴图...');
                    
                    for (const file of files) {
                        // 检查文件类型：支持常见图片格式和SVG
                        const supportedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
                        const isSupported = supportedTypes.includes(file.type) || 
                                          file.name.toLowerCase().endsWith('.svg') ||
                                          file.type.startsWith('image/');
                        
                        if (!isSupported) {
                            console.warn('跳过不支持的文件格式:', file.name, file.type);
                            continue;
                        }
                        
                        // 文件大小限制：5MB，SVG可以适当放宽到10MB
                        const maxSize = file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg') 
                                      ? 10 * 1024 * 1024  // SVG: 10MB
                                      : 5 * 1024 * 1024;   // 其他图片: 5MB
                        
                        if (file.size > maxSize) {
                            const sizeLimitMB = maxSize / (1024 * 1024);
                            showToast(`文件 ${file.name} 超过 ${sizeLimitMB}MB 大小限制`);
                            continue;
                        }
                        
                        // 生成唯一ID
                        const stickerId = 'sticker_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        
                        if (fileStorageManager) {
                            // 直接使用FileStorageManager存储文件到IndexedDB
                            try {
                                const storeResult = await fileStorageManager.storeFile(file, {
                                    category: 'bubble_sticker',
                                    originalName: file.name
                                });
                                
                                // storeResult 是一个对象 {fileId, type, size}，我们需要 fileId
                                const actualFileId = storeResult.fileId;
                                console.log('存储结果:', storeResult, '实际fileId:', actualFileId, '类型:', typeof actualFileId);
                                
                                // 创建文件引用
                                await fileStorageManager.createFileReference(
                                    actualFileId,
                                    'bubble_sticker',
                                    stickerId,
                                    {
                                        originalName: file.name,
                                        fileType: storeResult.type,
                                        fileSize: storeResult.size
                                    }
                                );
                                
                                // 创建贴图记录（保存fileId字符串，用于获取fileSystem引用）
                                const newSticker = {
                                    id: stickerId,
                                    fileId: actualFileId,
                                    originalName: file.name,
                                    fileType: storeResult.type,
                                    fileSize: storeResult.size,
                                    createdAt: new Date().toISOString()
                                };
                                
                                stickerLibrary.push(newSticker);
                                console.log('贴图存储成功(IndexedDB+FileSystem):', newSticker);
                                
                            } catch (error) {
                                console.error('FileStorageManager存储失败，回退到base64:', error);
                                // 回退到base64存储
                                await handleStickerUploadFallback(file, stickerId);
                            }
                        } else {
                            // 回退到base64存储
                            await handleStickerUploadFallback(file, stickerId);
                        }
                    }
                    
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                    showToast(`成功上传 ${files.length} 个贴图`, 'success');
                    
                } catch (error) {
                    console.error('贴图上传失败:', error);
                    
                    // 使用详细的错误处理逻辑
                    if (error && error.name === 'DetailedError') {
                        switch(error.code) {
                            case 'FILE_MISSING':
                            case 'PARAM_MISSING':
                                showToast(error.message, 'warning');
                                break;
                            case 'FILE_TOO_LARGE':
                            case 'INVALID_FILE_TYPE':
                                showToast(error.message, 'error');
                                break;
                            case 'STORAGE_FULL':
                                showToast(error.message, 'error');
                                break;
                            case 'DATABASE_ERROR':
                                showToast(error.message, 'error');
                                break;
                            case 'SYSTEM_ERROR':
                                showToast(error.message, 'warning');
                                break;
                            default:
                                showToast(error.message, 'error');
                                break;
                        }
                    } else {
                        showToast('贴图上传失败: ' + (error.message || '未知错误'), 'error');
                    }
                }
                
                event.target.value = '';
            }
            
            // 回退到base64存储的函数
            async function handleStickerUploadFallback(file, stickerId) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const newSticker = {
                            id: stickerId,
                            baseSrc: e.target.result,
                            currentSrc: e.target.result,
                            originalName: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            createdAt: new Date().toISOString(),
                            isBase64: true // 标记为base64存储
                        };
                        stickerLibrary.push(newSticker);
                        console.log('贴图base64存储成功:', newSticker);
                        resolve();
                    };
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(file);
                });
            }
            
            // SVG代码处理函数
            function validateSvgCode(svgCode) {
                // 基本验证：检查是否包含svg标签
                const svgRegex = /<svg[\s\S]*?<\/svg>/i;
                if (!svgRegex.test(svgCode)) {
                    return { valid: false, error: 'SVG代码必须包含完整的<svg>...</svg>标签' };
                }
                
                // 检查是否包含潜在的危险内容（基础安全检查）
                const dangerousPatterns = [
                    /<script/i,
                    /javascript:/i,
                    /on\w+\s*=/i,  // onclick, onload等事件
                ];
                
                for (const pattern of dangerousPatterns) {
                    if (pattern.test(svgCode)) {
                        return { valid: false, error: 'SVG代码包含不安全的内容' };
                    }
                }
                
                return { valid: true };
            }
            
            function normalizeSvgCode(svgCode) {
                // 清理和规范化SVG代码
                let cleaned = svgCode.trim();
                
                // 如果没有XML声明，确保SVG有正确的命名空间
                if (!cleaned.includes('xmlns=')) {
                    cleaned = cleaned.replace(
                        /<svg/i, 
                        '<svg xmlns="http://www.w3.org/2000/svg"'
                    );
                }
                
                // 如果没有viewBox，尝试从width/height生成一个
                if (!cleaned.includes('viewBox') && cleaned.includes('width=') && cleaned.includes('height=')) {
                    const widthMatch = cleaned.match(/width="?(\d+)"?/i);
                    const heightMatch = cleaned.match(/height="?(\d+)"?/i);
                    if (widthMatch && heightMatch) {
                        const width = widthMatch[1];
                        const height = heightMatch[1];
                        cleaned = cleaned.replace(
                            /<svg([^>]*)>/i,
                            `<svg$1 viewBox="0 0 ${width} ${height}">`
                        );
                    }
                }
                
                return cleaned;
            }
            
            async function handleSvgCodeInput() {
                const svgCode = controls.svgCodeInput.value.trim();
                
                if (!svgCode) {
                    showToast('请输入SVG代码');
                    return;
                }
                
                try {
                    // 验证SVG代码
                    const validation = validateSvgCode(svgCode);
                    if (!validation.valid) {
                        showToast('错误: ' + validation.error);
                        return;
                    }
                    
                    // 规范化SVG代码
                    const normalizedSvg = normalizeSvgCode(svgCode);
                    
                    // 创建SVG Blob
                    const svgBlob = new Blob([normalizedSvg], { type: 'image/svg+xml' });
                    
                    // 检查大小限制 (10MB)
                    if (svgBlob.size > 10 * 1024 * 1024) {
                        showToast('SVG代码过大，请尝试简化');
                        return;
                    }
                    
                    showToast('正在添加SVG贴图...');
                    
                    // 生成唯一ID
                    const stickerId = 'sticker_svg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    if (fileStorageManager) {
                        try {
                            // 使用FileStorageManager存储SVG
                            const storeResult = await fileStorageManager.storeFile(svgBlob, {
                                category: 'bubble_sticker',
                                originalName: `svg_${Date.now()}.svg`,
                                isUserCreated: true
                            });
                            
                            const actualFileId = typeof storeResult.fileId === 'string' 
                                               ? storeResult.fileId 
                                               : String(storeResult.fileId);
                            
                            // 创建文件引用
                            await fileStorageManager.createFileReference(
                                actualFileId,
                                'bubble_sticker',
                                stickerId,
                                {
                                    originalName: `svg_${Date.now()}.svg`,
                                    fileType: 'image/svg+xml',
                                    isUserCreated: true
                                }
                            );
                            
                            // 创建贴图记录
                            const newSticker = {
                                id: stickerId,
                                fileId: actualFileId,
                                originalName: `svg_${Date.now()}.svg`,
                                fileType: 'image/svg+xml',
                                fileSize: svgBlob.size,
                                createdAt: new Date().toISOString(),
                                isUserCreated: true
                            };
                            
                            stickerLibrary.push(newSticker);
                            console.log('SVG贴图存储成功(IndexedDB+FileSystem):', newSticker);
                            
                        } catch (error) {
                            console.error('FileStorageManager存储失败，回退到base64:', error);
                            // 回退到base64存储
                            await handleSvgFallbackStorage(normalizedSvg, stickerId);
                        }
                    } else {
                        // 回退到base64存储
                        await handleSvgFallbackStorage(normalizedSvg, stickerId);
                    }
                    
                    // 保存和更新界面
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                    showToast('SVG贴图添加成功！');
                    
                    // 清空输入框
                    controls.svgCodeInput.value = '';
                    
                } catch (error) {
                    console.error('SVG处理失败:', error);
                    showToast('SVG处理失败: ' + error.message);
                }
            }
            
            async function handleSvgFallbackStorage(svgCode, stickerId) {
                // 转换为data URL
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgCode)));
                
                const newSticker = {
                    id: stickerId,
                    baseSrc: dataUrl,
                    currentSrc: dataUrl,
                    originalName: `svg_${Date.now()}.svg`,
                    fileType: 'image/svg+xml',
                    fileSize: svgCode.length,
                    createdAt: new Date().toISOString(),
                    isBase64: true,
                    isUserCreated: true
                };
                
                stickerLibrary.push(newSticker);
                console.log('SVG贴图base64存储成功:', newSticker);
            }
            
            async function populateStickerGallery() {
                stickerGallery.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const container = document.createElement('div');
                    container.className = 'relative group';
                    
                    const img = document.createElement('img');
                    img.className = 'w-full h-full object-contain bg-slate-200 rounded-md cursor-pointer hover:ring-2 ring-indigo-500';
                    img.dataset.id = sticker.id;
                    img.addEventListener('click', () => selectStickerForEditing(sticker.id));
                    
                    // 获取图片URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            // 使用FileStorageManager获取fileSystem引用URL
                            console.log('尝试获取图片URL，fileId:', sticker.fileId, '类型:', typeof sticker.fileId);
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            // 回退到base64
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('贴图无有效的图片源:', sticker);
                            imageUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4='; // 占位符SVG
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('获取贴图URL失败:', error);
                        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4=';
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity z-10';
                    deleteBtn.addEventListener('click', async (e) => { 
                        e.stopPropagation(); 
                        if (confirm('确定要删除这个贴纸吗？此操作将永久删除文件且无法恢复。')) {
                            await deleteSticker(sticker.id); 
                        }
                    });
                    
                    container.appendChild(img);
                    container.appendChild(deleteBtn);
                    stickerGallery.appendChild(container);
                }
            }
            
            async function deleteSticker(id) {
                // 首先获取要删除的贴纸信息，以便清理文件存储
                const stickerToDelete = stickerLibrary.find(s => s.id === id);
                
                if (stickerToDelete && stickerToDelete.fileId && fileStorageManager) {
                    try {
                        console.log('清理贴纸文件存储，stickerId:', id, 'fileId:', stickerToDelete.fileId);
                        
                        // 删除文件引用
                        await fileStorageManager.deleteFileReference('bubble_sticker_' + id);
                        console.log('文件引用删除成功');
                        
                        // 删除实际文件（FileStorageManager会检查是否还有其他引用）
                        await fileStorageManager.deleteFile(stickerToDelete.fileId);
                        console.log('文件存储删除成功');
                        
                    } catch (error) {
                        console.error('清理文件存储失败:', error);
                        // 即使文件存储清理失败，也继续删除贴纸记录
                    }
                }
                
                // 从贴纸库中移除
                stickerLibrary = stickerLibrary.filter(s => s.id != id);
                saveStickerLibraryToStorage();
                populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                
                if (currentEditingStickerId == id) {
                    currentEditingStickerId = null;
                    editorPlaceholder.classList.remove('hidden');
                    editorControls.classList.add('hidden');
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                }
            }

            async function renderStickerLibrary() {
                stickerLibraryContainer.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const img = document.createElement('img');
                    img.className = 'library-sticker';
                    img.dataset.id = sticker.id;
                    
                    // 获取图片URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('贴图无有效的图片源:', sticker);
                            continue; // 跳过无效贴图
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('获取贴图URL失败:', error);
                        continue; // 跳过失败的贴图
                    }
                    
                    makeLibraryStickerDraggable(img);
                    stickerLibraryContainer.appendChild(img);
                }
            }

            function selectStickerForEditing(id) {
                currentEditingStickerId = id;
                const sticker = stickerLibrary.find(s => s.id == id);
                if (!sticker) return;
                
                // 检查是否为SVG文件
                const isSVG = sticker.fileType === 'image/svg+xml' || 
                            sticker.originalName?.toLowerCase().endsWith('.svg');
                
                editorPlaceholder.classList.add('hidden');
                editorControls.classList.remove('hidden');
                
                // 如果是SVG文件，禁用背景移除相关功能
                const removeBgBtn = document.getElementById('removeBgBtn');
                const toleranceContainer = document.querySelector('#editorControls .space-y-2:nth-child(2)');
                
                if (isSVG) {
                    if (removeBgBtn) removeBgBtn.style.display = 'none';
                    if (toleranceContainer) toleranceContainer.style.display = 'none';
                    // 显示SVG提示信息
                    const existingNotice = document.getElementById('svgEditNotice');
                    if (!existingNotice) {
                        const notice = document.createElement('div');
                        notice.id = 'svgEditNotice';
                        notice.className = 'text-sm text-slate-600 bg-slate-100 p-2 rounded';
                        notice.textContent = 'SVG文件不支持背景移除功能';
                        removeBgBtn.parentNode.insertBefore(notice, removeBgBtn);
                    }
                } else {
                    if (removeBgBtn) removeBgBtn.style.display = 'block';
                    if (toleranceContainer) toleranceContainer.style.display = 'block';
                    // 移除SVG提示信息
                    const existingNotice = document.getElementById('svgEditNotice');
                    if (existingNotice) existingNotice.remove();
                }
                
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.currentSrc || sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    ctx.drawImage(img, 0, 0);
                }
            }
            
            function processImage(colorToRemove, tolerance) {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (!sticker) return;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    const data = imageData.data;
                    const [tr, tg, tb] = colorToRemove;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const distance = Math.sqrt(Math.pow(r - tr, 2) + Math.pow(g - tg, 2) + Math.pow(b - tb, 2));
                        if (distance < tolerance) { data[i + 3] = 0; }
                    }
                    ctx.putImageData(imageData, 0, 0);
                };
            }

            // 获取贴图URL的辅助函数
            async function getStickerImageURL(sticker) {
                try {
                    if (sticker.fileId && fileStorageManager) {
                        return await fileStorageManager.createFileURL(sticker.fileId);
                    } else if (sticker.currentSrc || sticker.baseSrc) {
                        return sticker.currentSrc || sticker.baseSrc;
                    } else {
                        console.warn('贴图无有效的图片源:', sticker);
                        return null;
                    }
                } catch (error) {
                    console.error('获取贴图URL失败:', error);
                    return sticker.currentSrc || sticker.baseSrc || null;
                }
            }

            function makeLibraryStickerDraggable(element) {
                element.addEventListener('mousedown', async (e) => {
                    e.preventDefault();
                    
                    if (currentThemeName === 'default') {
                        showToast('默认主题不支持添加贴纸，请新建主题后使用', 'info');
                        return;
                    }
                    
                    const stickerData = stickerLibrary.find(s => s.id == element.dataset.id);
                    if (!stickerData) return;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = zIndexCounter++; 
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // 异步获取图片URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (!imageUrl) {
                        console.error('无法获取贴图URL，跳过创建');
                        return;
                    }
                    newSticker.src = imageUrl;
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    
                    // 根据当前选择的气泡类型添加贴图
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                    targetBubble.appendChild(wrapper);

                    const bubbleRect = targetBubble.getBoundingClientRect();
                    const initialWidth = 120;
                    wrapper.style.width = `${initialWidth}px`;
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.naturalHeight / tempImg.naturalWidth;
                        wrapper.style.height = `${initialWidth * aspectRatio}px`;
                        wrapper.style.left = `${(bubbleRect.width - wrapper.offsetWidth) / 2}px`;
                        wrapper.style.top = `${(bubbleRect.height - wrapper.offsetHeight) / 2}px`;
                    };
                    
                    makePlacedStickerInteractive(wrapper);
                    
                    // 添加贴纸后更新交互状态
                    updateStickersInteractionState();
                });
            }
            
            function makePlacedStickerInteractive(wrapper) {
                const resizeHandle = wrapper.querySelector('.resize-handle');
                let isDragging = false, isResizing = false;
                let offsetX, offsetY;

                function getCurrentBubbleContainer() {
                    // 获取当前选中的气泡容器
                    const currentType = getCurrentBubbleType();
                    return currentType === 'self' ? previewBubbleSelf : previewBubbleKare;
                }

                function isCurrentBubbleSticker() {
                    // 检查这个贴纸是否属于当前选中的气泡
                    const currentBubble = getCurrentBubbleContainer();
                    return currentBubble.contains(wrapper);
                }

                function onMoveDown(e) {
                    // 只允许当前选中气泡中的贴纸交互
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    isDragging = true;
                    wrapper.classList.add('dragging');
                    const event = e.touches ? e.touches[0] : e;
                    const rect = wrapper.getBoundingClientRect();
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    offsetX = event.clientX - rect.left;
                    offsetY = event.clientY - rect.top;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onMoveUp);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onMoveUp);
                }
                function onMove(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    wrapper.style.left = `${event.clientX - bubbleRect.left - offsetX}px`;
                    wrapper.style.top = `${event.clientY - bubbleRect.top - offsetY}px`;
                }
                function onMoveUp() {
                    isDragging = false;
                    wrapper.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onMoveUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onMoveUp);
                }
                wrapper.addEventListener('mousedown', onMoveDown);
                wrapper.addEventListener('touchstart', onMoveDown, { passive: false });

                function onResizeDown(e) {
                    // 只允许当前选中气泡中的贴纸交互
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    isResizing = true;
                    const event = e.touches ? e.touches[0] : e;
                    const initialWidth = wrapper.offsetWidth;
                    const initialHeight = wrapper.offsetHeight;
                    const initialX = event.clientX;
                    const initialY = event.clientY;

                    function onResizeMove(e) {
                        if (!isResizing) return;
                        const event = e.touches ? e.touches[0] : e;
                        const deltaX = event.clientX - initialX;
                        const deltaY = event.clientY - initialY;
                        const newWidth = Math.max(20, initialWidth + deltaX);
                        const newHeight = Math.max(20, initialHeight + deltaY);
                        wrapper.style.width = `${newWidth}px`;
                        wrapper.style.height = `${newHeight}px`;
                    }

                    function onResizeUp() {
                        isResizing = false;
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeUp);
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeUp);
                    }
                    
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeUp);
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeUp);
                }
                resizeHandle.addEventListener('mousedown', onResizeDown);
                resizeHandle.addEventListener('touchstart', onResizeDown, { passive: false });

                wrapper.addEventListener('dblclick', () => {
                    // 只允许当前选中气泡中的贴纸删除
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    wrapper.remove();
                    showToast('贴图已移除');
                });

                wrapper.addEventListener('click', (e) => {
                    // 只允许当前选中气泡中的贴纸被选择
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    selectSticker(wrapper);
                });
            }

            function selectSticker(wrapper) {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.remove('selected');
                }
                selectedStickerWrapper = wrapper;
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.add('selected');
                    controls.sendToBackBtn.disabled = false;
                    controls.bringToFrontBtn.disabled = false;
                } else {
                    controls.sendToBackBtn.disabled = true;
                    controls.bringToFrontBtn.disabled = true;
                }
            }
            previewContainer.addEventListener('click', (e) => {
                if (e.target === previewContainer || e.target === previewBubbleSelf || e.target === previewBubbleKare) {
                    selectSticker(null);
                }
            });

            controls.sendToBackBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = 1;
                    showToast('已置于文字底层');
                }
            });
            controls.bringToFrontBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = zIndexCounter++;
                    showToast('已置于文字顶层');
                }
            });


            controls.manageStickersBtn.addEventListener('click', openProcessor);
            controls.closeProcessorBtn.addEventListener('click', closeProcessor);
            controls.galleryStickerUpload.addEventListener('change', handleStickerUpload);
            
            // SVG代码输入相关事件
            controls.toggleSvgInputBtn.addEventListener('click', () => {
                const isHidden = controls.svgInputSection.classList.contains('hidden');
                if (isHidden) {
                    controls.svgInputSection.classList.remove('hidden');
                    controls.toggleSvgInputBtn.textContent = '隐藏SVG输入';
                } else {
                    controls.svgInputSection.classList.add('hidden');
                    controls.toggleSvgInputBtn.textContent = '输入SVG代码';
                }
            });
            
            controls.addSvgBtn.addEventListener('click', handleSvgCodeInput);
            controls.clearSvgBtn.addEventListener('click', () => {
                controls.svgCodeInput.value = '';
                showToast('已清空SVG代码');
            });
            
            // 支持Ctrl+Enter快捷键提交SVG
            controls.svgCodeInput.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    handleSvgCodeInput();
                }
            });
            controls.removeBgBtn.addEventListener('click', () => imageEditorCanvas.classList.add('dropper-cursor'));
            imageEditorCanvas.addEventListener('click', (e) => {
                if (!imageEditorCanvas.classList.contains('dropper-cursor')) return;
                const rect = imageEditorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                targetColor = [pixel[0], pixel[1], pixel[2]];
                imageEditorCanvas.classList.remove('dropper-cursor');
                processImage(targetColor, controls.tolerance.value);
            });
            controls.tolerance.addEventListener('input', () => {
                controls.toleranceValue.textContent = controls.tolerance.value;
                if (currentEditingStickerId && targetColor) {
                    processImage(targetColor, controls.tolerance.value);
                }
            });
            controls.saveChangesBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = imageEditorCanvas.toDataURL();
                    saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                }
            });
            controls.resetStickerBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = sticker.baseSrc;
                    saveStickerLibraryToStorage();
                    selectStickerForEditing(sticker.id);
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                }
            });

            // 【修改】将 textColor 和 fontFamily 添加到事件监听循环中
            ['borderWidth', 'borderColor', 'borderRadius', 'bgColor', 'bgOpacity', 'gradientColor1', 'gradientColor2', 'gradientAngle', 'textColor', 'fontFamily'].forEach(id => { if (controls[id]) { controls[id].addEventListener('input', updateBubbleStyle); } });
            controls.bubbleText.addEventListener('input', () => { 
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                currentTextContent.textContent = controls.bubbleText.value; 
            });
            controls.bgTypeSolid.addEventListener('click', () => { currentBgType = 'solid'; controls.solidBgControls.classList.remove('hidden'); controls.gradientBgControls.classList.add('hidden'); controls.bgTypeSolid.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.remove('text-slate-600'); controls.bgTypeGradient.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.add('text-slate-600'); updateBubbleStyle(); });
            controls.bgTypeGradient.addEventListener('click', () => { currentBgType = 'gradient'; controls.solidBgControls.classList.add('hidden'); controls.gradientBgControls.classList.remove('hidden'); controls.bgTypeGradient.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.remove('text-slate-600'); controls.bgTypeSolid.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.add('text-slate-600'); updateBubbleStyle(); });

            // 气泡类型切换事件监听器
            controls.bubbleTypeSelf.addEventListener('click', () => switchBubbleType('self'));
            controls.bubbleTypeKare.addEventListener('click', () => switchBubbleType('kare'));
            
            // CSS样式解析辅助函数
            function extractRgbColor(colorValue) {
                if (!colorValue) return '#ffffff';
                // 如果是rgb/rgba格式，提取RGB部分
                const match = colorValue.match(/rgba?\(([^)]+)\)/);
                if (match) {
                    const values = match[1].split(',').map(v => parseInt(v.trim()));
                    return `#${values.slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')}`;
                }
                // 如果已经是hex格式，直接返回
                if (colorValue.startsWith('#')) return colorValue;
                return '#ffffff';
            }

            function extractAlpha(colorValue) {
                if (!colorValue) return 1;
                const match = colorValue.match(/rgba?\([^,]+,[^,]+,[^,]+,?\s*([^)]*)\)/);
                if (match && match[1]) {
                    return parseFloat(match[1]) || 1;
                }
                return 1;
            }

            function extractGradientColors(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return ['#ffffff', '#ffffff'];
                }
                // 匹配gradient中的颜色
                const colorMatches = backgroundValue.match(/(#[0-9a-fA-F]{6}|rgb\([^)]+\)|rgba\([^)]+\))/g);
                if (colorMatches && colorMatches.length >= 2) {
                    return [extractRgbColor(colorMatches[0]), extractRgbColor(colorMatches[1])];
                }
                return ['#ffffff', '#ffffff'];
            }

            function extractGradientAngle(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return 0;
                }
                const angleMatch = backgroundValue.match(/(\d+)deg/);
                return angleMatch ? parseInt(angleMatch[1]) : 0;
            }

            // 为指定气泡类型生成完整配置
            function generateBubbleConfig(bubbleType) {
                const targetBubble = bubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const targetTextContent = bubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                const bubbleStyle = window.getComputedStyle(targetBubble);
                const textStyle = window.getComputedStyle(targetTextContent);
                
                // 生成贴纸HTML
                let htmlStickers = '';
                const bubbleWidth = targetBubble.offsetWidth;
                const bubbleHeight = targetBubble.offsetHeight;

                targetBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src;

                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';
                    if (leftPercent < 0.33 && topPercent < 0.33) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent < 0.33) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent < 0.33 && topPercent > 0.67) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent > 0.67) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else {
                        positionStyle = `left: ${((leftPx + stickerWidth / 2) / bubbleWidth * 100).toFixed(1)}%; top: ${((topPx + stickerHeight / 2) / bubbleHeight * 100).toFixed(1)}%; transform: translate(-50%, -50%);`;
                    }
                    
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });

                const htmlTemplate = `<div class="chat-bubble" style="background: ${bubbleStyle.background || bubbleStyle.backgroundColor}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; padding: 12px; margin-bottom: 8px; max-width: 80%; word-wrap: break-word; position: relative; color: ${textStyle.color}; font-family: ${textStyle.fontFamily};">\\n    {{BUBBLE_TEXT}}\\n${htmlStickers}</div>`;

                return {
                    borderWidth: parseInt(controls.borderWidth.value) || 1,
                    borderColor: controls.borderColor.value || '#4f46e5',
                    borderRadius: parseInt(controls.borderRadius.value) || 12,
                    backgroundColor: controls.bgColor.value || '#ffffff',
                    backgroundOpacity: parseFloat(controls.bgOpacity.value) || 1,
                    backgroundType: currentBgType, // 直接使用当前的背景类型，而不是从样式推断
                    gradientColor1: controls.gradientColor1.value || '#a5b4fc',
                    gradientColor2: controls.gradientColor2.value || '#e0e7ff',  
                    gradientAngle: controls.gradientAngle.value || 145,
                    textColor: controls.textColor.value || '#333333',
                    fontFamily: controls.fontFamily.value || 'Inter',
                    // bubbleText: 不保存文本内容，每次使用默认值
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => {
                        const stickerId = wrapper.dataset.id;
                        const stickerInfo = stickerLibrary.find(s => s.id === stickerId);
                        return {
                            id: stickerId,
                            fileId: stickerInfo?.fileId || '',
                            left: parseFloat(wrapper.style.left) || 0,
                            top: parseFloat(wrapper.style.top) || 0,
                            width: wrapper.offsetWidth,
                            height: wrapper.offsetHeight,
                            zIndex: wrapper.style.zIndex || 1
                        };
                    }),
                    html: htmlTemplate,
                    enabled: true
                };
            }

            // 共享的保存配置函数
            async function saveCurrentConfiguration() {
                console.log('开始保存当前配置...', `当前气泡类型: ${currentBubbleType}`);
                
                // 1. 生成当前选择气泡类型的HTML和CSS代码（用于显示）
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                const bubbleStyle = window.getComputedStyle(currentBubble);
                const textStyle = window.getComputedStyle(currentTextContent);
                
                console.log(`当前${currentBubbleType}气泡的样式:`, {
                    backgroundType: currentBgType,
                    backgroundColor: controls.bgColor.value,
                    gradientColor1: controls.gradientColor1.value,
                    gradientColor2: controls.gradientColor2.value
                });
                
                // 2. 保存当前UI状态到缓存
                uiStateCache[currentBubbleType] = captureCurrentUIState();
                
                // 3. 确保双方气泡状态都已缓存
                console.log('当前缓存状态:', {
                    self: uiStateCache.self ? '已缓存' : '未缓存',
                    kare: uiStateCache.kare ? '已缓存' : '未缓存'
                });
                
                // 如果self气泡未缓存，临时切换到self以缓存其状态
                if (!uiStateCache.self && currentBubbleType !== 'self') {
                    console.log('切换到self以缓存其状态');
                    const originalType = currentBubbleType;
                    await switchBubbleType('self');
                    // 切换回来
                    await switchBubbleType(originalType);
                }
                
                // 如果kare气泡未缓存，临时切换到kare以缓存其状态
                if (!uiStateCache.kare && currentBubbleType !== 'kare') {
                    console.log('切换到kare以缓存其状态');
                    const originalType = currentBubbleType;
                    await switchBubbleType('kare');
                    // 切换回来
                    await switchBubbleType(originalType);
                }
                
                // 从缓存获取双方配置
                const selfConfig = uiStateCache.self || { ...DEFAULT_THEME_CONFIG.self, stickers: [] };
                const kareConfig = uiStateCache.kare || { ...DEFAULT_THEME_CONFIG.kare, stickers: [] };
                
                console.log('从缓存获取配置完成:', {
                    self: {
                        backgroundType: selfConfig.backgroundType,
                        backgroundColor: selfConfig.backgroundColor,
                        textColor: selfConfig.textColor
                    },
                    kare: {
                        backgroundType: kareConfig.backgroundType,
                        backgroundColor: kareConfig.backgroundColor,
                        textColor: kareConfig.textColor
                    }
                });
                
                // 生成HTML模板（主应用要求必须有html字段）
                const generateHtmlTemplate = (config, bubbleType) => {
                    // 生成背景样式
                    let backgroundStyle = '';
                    if (config.backgroundType === 'gradient') {
                        backgroundStyle = `linear-gradient(${config.gradientAngle}deg, ${config.gradientColor1}, ${config.gradientColor2})`;
                    } else {
                        const bgColor = config.backgroundColor || '#ffffff';
                        const opacity = config.backgroundOpacity || 1;
                        // 简化处理，直接使用颜色和透明度
                        backgroundStyle = `${bgColor}`;
                        if (opacity < 1) {
                            // 如果有透明度，转换为rgba格式
                            const r = parseInt(bgColor.slice(1, 3), 16);
                            const g = parseInt(bgColor.slice(3, 5), 16);
                            const b = parseInt(bgColor.slice(5, 7), 16);
                            backgroundStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                    
                    // 生成贴纸HTML - 使用fileId格式供主应用解析
                    let stickersHtml = '';
                    if (config.stickers && config.stickers.length > 0) {
                        stickersHtml = config.stickers.map(sticker => 
                            `<img src="file:${sticker.fileId || ''}" class="sticker" data-file-id="${sticker.fileId || ''}" style="position: absolute; left: ${sticker.left || 0}px; top: ${sticker.top || 0}px; width: ${sticker.width || 50}px; height: ${sticker.height || 50}px; z-index: ${sticker.zIndex || 1}; user-select: none; pointer-events: none;">`
                        ).join('');
                    }
                    
                    return `<div class="custom-bubble-container" style="position: relative; padding: 8px 12px; border: ${config.borderWidth}px solid ${config.borderColor}; border-radius: ${config.borderRadius}px; background: ${backgroundStyle};">
    <span class="bubble-text" style="position: relative; z-index: 10; color: ${config.textColor}; font-family: '${config.fontFamily}';">{{BUBBLE_TEXT}}</span>
    ${stickersHtml}
</div>`;
                };
                
                // 格式化配置用于保存（包含HTML模板）
                const formatConfigForSave = (config, bubbleType) => ({
                    borderWidth: parseInt(config.borderWidth) || 1,
                    borderColor: config.borderColor || '#4f46e5',
                    borderRadius: parseInt(config.borderRadius) || 12,
                    backgroundColor: config.backgroundColor || '#ffffff',
                    backgroundOpacity: parseFloat(config.backgroundOpacity) || 1,
                    backgroundType: config.backgroundType || 'solid',
                    gradientColor1: config.gradientColor1 || '#a5b4fc',
                    gradientColor2: config.gradientColor2 || '#e0e7ff',
                    gradientAngle: parseInt(config.gradientAngle) || 145,
                    textColor: config.textColor || '#333333',
                    fontFamily: config.fontFamily || 'Inter',
                    stickers: config.stickers || [],
                    html: generateHtmlTemplate(config, bubbleType), // 添加HTML模板，传入气泡类型
                    css: '/* CSS已内联到HTML中 */', // 添加CSS字段
                    createdAt: new Date().toISOString(),
                    enabled: true
                });
                
                const formattedSelfConfig = formatConfigForSave(selfConfig, 'self');
                const formattedKareConfig = formatConfigForSave(kareConfig, 'kare');
                
                // 添加调试日志
                console.log('保存的配置详情:', {
                    self: {
                        backgroundType: formattedSelfConfig.backgroundType,
                        backgroundColor: formattedSelfConfig.backgroundColor,
                        textColor: formattedSelfConfig.textColor
                    },
                    kare: {
                        backgroundType: formattedKareConfig.backgroundType,
                        backgroundColor: formattedKareConfig.backgroundColor,
                        textColor: formattedKareConfig.textColor
                    }
                });
                
                // 同时保存双方的配置
                await saveBubbleStyleConfig(formattedSelfConfig, 'bubbleStyleSelf');
                await saveBubbleStyleConfig(formattedKareConfig, 'bubbleStyle');
                
                // 如果当前处于自定义主题，同时更新主题数据
                if (currentThemeName !== 'default') {
                    try {
                        const themeData = {
                            type: `theme_${currentThemeName}`,
                            name: currentThemeName,
                            updatedAt: new Date().toISOString(),
                            bubbleStyles: {
                                self: formattedSelfConfig,
                                kare: formattedKareConfig
                            },
                            stickerLibrary: stickerLibrary || []
                        };
                        
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        await new Promise((resolve, reject) => {
                            const request = store.put(themeData);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        
                        console.log(`主题"${currentThemeName}"数据已同步更新`);
                    } catch (error) {
                        console.error('更新主题数据失败:', error);
                    }
                }
                
                return { selfConfig: formattedSelfConfig, kareConfig: formattedKareConfig };
            }
            
            // "保存"按钮事件处理器
            controls.saveOnlyBtn.addEventListener('click', async () => {
                try {
                    await saveCurrentConfiguration();
                    
                    showToast('配置已保存！', 'success');
                    const originalText = controls.saveOnlyBtn.textContent;
                    controls.saveOnlyBtn.textContent = '✅ 已保存!';
                    setTimeout(() => {
                        controls.saveOnlyBtn.textContent = originalText;
                    }, 2000);
                } catch (error) {
                    console.error('保存失败:', error);
                    showToast('保存失败: ' + error.message, 'error');
                }
            });
            
            // "保存并应用"按钮事件处理器  
            controls.generateCodeBtn.addEventListener('click', async () => {
                try {
                    // 1. 先执行常规保存
                    const { selfConfig, kareConfig } = await saveCurrentConfiguration();
                    
                    // 2. 写入主应用使用的themeConfig位置
                    console.log('写入主应用使用的配置位置...');
                    await saveBubbleStyleConfig(selfConfig, 'bubbleStyleSelf');
                    await saveBubbleStyleConfig(kareConfig, 'bubbleStyle');
                    
                    // 3. 确保主应用能读取到最新配置（直接更新themeConfig表）
                    try {
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        // 保存为主应用直接读取的键名
                        await new Promise((resolve, reject) => {
                            const request1 = store.put({ type: 'bubbleStyleSelf', ...selfConfig, updatedAt: new Date().toISOString() });
                            request1.onsuccess = () => resolve();
                            request1.onerror = () => reject(request1.error);
                        });
                        
                        await new Promise((resolve, reject) => {
                            const request2 = store.put({ type: 'bubbleStyle', ...kareConfig, updatedAt: new Date().toISOString() });
                            request2.onsuccess = () => resolve();
                            request2.onerror = () => reject(request2.error);
                        });
                        
                        console.log('主应用配置已更新');
                    } catch (error) {
                        console.warn('更新主应用配置失败，但不影响基本保存功能:', error);
                    }
                    
                    // 4. 发送配置给主应用（postMessage）- 发送两个独立的消息
                    console.log('发送气泡样式给主应用...');
                    
                    // 发送"我的"气泡样式
                    window.parent.postMessage({
                        type: 'apply-bubble-style',
                        payload: selfConfig,
                        bubbleType: 'self'
                    }, '*');
                    
                    // 发送"对方"气泡样式  
                    window.parent.postMessage({
                        type: 'apply-bubble-style',
                        payload: kareConfig,
                        bubbleType: 'kare'
                    }, '*');
                    
                    console.log('已发送双方气泡样式配置给主应用');
                    
                    showToast('已保存双方气泡样式并应用到聊天界面！', 'success');
                    const originalText = controls.generateCodeBtn.textContent;
                    controls.generateCodeBtn.textContent = '✅ 已应用!';
                    setTimeout(() => {
                        controls.generateCodeBtn.textContent = originalText;
                    }, 2000);
                
                } catch (error) {
                    console.error('保存并应用失败:', error);
                    showToast('保存并应用失败: ' + error.message, 'error');
                }
            });
            
            // 保存气泡样式配置到IndexedDB
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {

                // 7. 给用户一个反馈
                showToast('已保存双方气泡样式并应用到聊天界面！');
                const originalText = controls.generateCodeBtn.textContent;
                controls.generateCodeBtn.textContent = '✅ 已应用!';
                setTimeout(() => {
                    controls.generateCodeBtn.textContent = originalText;
                }, 2000);
            };


            // 保存完整的气泡样式配置
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过保存配置');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 将 enabled 属性添加到 styleConfig 本身
                    const configData = {
                        type: styleKey,
                        ...styleConfig, // 展开所有样式配置到顶层
                        enabled: true,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(configData);
                    
                    transaction.oncomplete = () => {
                        console.log(`${styleKey}配置保存成功`);
                    };
                    
                    transaction.onerror = () => {
                        console.error(`${styleKey}配置保存失败:`, transaction.error);
                    };
                } catch (e) {
                    console.error(`无法保存${styleKey}配置:`, e);
                }
            }

  
            // 重置所有控件到默认值
            function resetControlsToDefault() {
                // 重置基础样式控件
                controls.bgColor.value = '#3b82f6';
                controls.textColor.value = '#ffffff';
                controls.borderRadius.value = 18;
                controls.borderWidth.value = 0;
                controls.borderColor.value = '#e2e8f0';
                controls.bgOpacity.value = 1;
                controls.borderOpacity.value = 1;
                
                // 重置渐变相关
                controls.bgType.value = 'solid';
                controls.gradientType.value = 'linear';
                controls.gradientColor1.value = '#3b82f6';
                controls.gradientColor2.value = '#1d4ed8';
                controls.gradientAngle.value = 45;
                
                // 重置文本内容为当前气泡类型的默认值
                const defaultText = currentBubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                controls.bubbleText.value = defaultText;
                
                // 同时更新预览显示
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                currentTextContent.textContent = defaultText;
                
                // 更新显示值
                updateValueDisplays();
                
                // 重新应用样式到预览气泡
                updateBubblePreview();
                
                console.log('所有控件已重置到默认值');
            }

            // 加载完整的气泡样式配置
            async function loadBubbleStyleConfig(styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过加载配置');
                        return null;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get(styleKey);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result) {
                                console.log(`${styleKey}配置加载成功`);
                                // 移除 type 和系统字段，返回样式配置
                                const { type, lastModified, ...styleConfig } = result;
                                resolve(styleConfig);
                            } else {
                                console.log(`未找到已保存的${styleKey}配置`);
                                resolve(null);
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`加载${styleKey}配置失败:`, request.error);
                            resolve(null);
                        };
                    });
                } catch (e) {
                    console.error(`无法加载${styleKey}配置:`, e);
                    return null;
                }
            }

            // 应用保存的配置到界面
            async function applyBubbleStyleConfig(config) {
                if (!config) return;
                
                try {
                    // 应用基础样式 - 使用颜色转换确保格式正确
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = extractRgbColor(config.borderColor) || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = extractRgbColor(config.textColor) || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    // 应用背景样式 - 使用颜色转换确保格式正确
                    currentBgType = config.backgroundType || 'solid';
                    controls.bgColor.value = extractRgbColor(config.backgroundColor) || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = extractRgbColor(config.gradientColor1) || '#a5b4fc';
                    controls.gradientColor2.value = extractRgbColor(config.gradientColor2) || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // 切换背景类型
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // 文本内容始终使用默认值，不从配置中应用
                    const defaultText = currentBubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                    currentTextContent.textContent = defaultText;
                    
                    // 恢复贴图（不在这里处理，在初始化函数中处理）
                    // if (config.stickers && config.stickers.length > 0) {
                    //     await restoreStickers(config.stickers, currentBubbleType);
                    // }
                    
                    // 更新样式
                    updateBubbleStyle();
                    
                    console.log('气泡样式配置已应用到界面');
                } catch (error) {
                    console.error('应用气泡样式配置失败:', error);
                }
            }

            // 恢复贴图
            async function restoreStickers(stickerConfigs, targetBubbleType = 'kare') {
                // 清除对应气泡的现有贴图
                const targetBubble = targetBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                
                for (const stickerConfig of stickerConfigs) {
                    const stickerData = stickerLibrary.find(s => s.id === stickerConfig.id);
                    if (!stickerData) {
                        console.warn('找不到贴图数据:', stickerConfig.id);
                        continue;
                    }
                    
                    // 创建贴图元素
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = stickerConfig.zIndex;
                    wrapper.style.left = stickerConfig.left + 'px';
                    wrapper.style.top = stickerConfig.top + 'px';
                    wrapper.style.width = stickerConfig.width + 'px';
                    wrapper.style.height = stickerConfig.height + 'px';
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // 获取图片URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (imageUrl) {
                        newSticker.src = imageUrl;
                    }
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    targetBubble.appendChild(wrapper);
                    
                    makePlacedStickerInteractive(wrapper);
                }
                
                // 恢复贴纸后更新交互状态
                updateStickersInteractionState();
            }

            // 异步初始化
            async function initializeApp() {
                console.log('=== 开始应用初始化 ===');
                
                await initStorageSystem();
                await loadStickerLibraryFromStorage();
                await renderStickerLibrary();
                
                // 初始化主题管理
                await loadAvailableThemes();
                
                // 检测用户当前使用的主题并自动切换
                const activeTheme = await detectCurrentActiveTheme();
                console.log(`检测到用户当前使用的主题: ${activeTheme}`);
                
                // 自动切换到检测到的主题
                await loadTheme(activeTheme);
                updateThemeSelector();
                
                console.log('=== 应用初始化完成 ===');
                
                // 默认切换到自己的气泡编辑模式
                await switchBubbleType('self');
            }
            // ==================== 多主题管理功能 ====================
            
            let currentThemeName = 'default';
            
            // 固定的默认主题配置
            const DEFAULT_THEME_CONFIG = {
                self: {
                    borderWidth: 0,
                    borderColor: '#ffffff',
                    borderRadius: 12,
                    backgroundColor: '#33f28c',
                    backgroundOpacity: 1,
                    backgroundType: 'solid',
                    gradientColor1: '#33f28c',
                    gradientColor2: '#33f28c',
                    gradientAngle: 145,
                    textColor: '#000000',
                    fontFamily: 'Inter',
                    stickers: [],
                    enabled: true
                },
                kare: {
                    borderWidth: 0,
                    borderColor: '#ffffff',
                    borderRadius: 12,
                    backgroundColor: '#ffffff',
                    backgroundOpacity: 1,
                    backgroundType: 'solid',
                    gradientColor1: '#ffffff',
                    gradientColor2: '#ffffff',
                    gradientAngle: 145,
                    textColor: '#000000',
                    fontFamily: 'Inter',
                    stickers: [],
                    enabled: true
                }
            };
            
            // UI状态缓存 - 保存双方气泡的当前编辑状态
            let uiStateCache = {
                self: null,
                kare: null
            };
            
            // 从UI控件读取指定气泡类型的状态
            function captureCurrentUIState(bubbleType = currentBubbleType) {
                const targetBubble = bubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                
                return {
                    borderWidth: controls.borderWidth.value,
                    borderColor: controls.borderColor.value,
                    borderRadius: controls.borderRadius.value,
                    textColor: controls.textColor.value,
                    fontFamily: controls.fontFamily.value,
                    backgroundColor: controls.bgColor.value,
                    backgroundOpacity: controls.bgOpacity.value,
                    backgroundType: currentBgType,
                    gradientColor1: controls.gradientColor1.value,
                    gradientColor2: controls.gradientColor2.value,
                    gradientAngle: controls.gradientAngle.value,
                    // 添加贴纸信息收集
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => {
                        const stickerId = wrapper.dataset.id;
                        const stickerInfo = stickerLibrary.find(s => s.id === stickerId);
                        return {
                            id: stickerId,
                            fileId: stickerInfo?.fileId || '',
                            left: parseFloat(wrapper.style.left) || 0,
                            top: parseFloat(wrapper.style.top) || 0,
                            width: wrapper.offsetWidth,
                            height: wrapper.offsetHeight,
                            zIndex: wrapper.style.zIndex || 1
                        };
                    })
                };
            }
            
            // 将状态应用到UI控件
            function applyUIState(state) {
                if (!state) return;
                
                controls.borderWidth.value = state.borderWidth || 1;
                controls.borderColor.value = state.borderColor || '#4f46e5';
                controls.borderRadius.value = state.borderRadius || 12;
                controls.textColor.value = state.textColor || '#333333';
                controls.fontFamily.value = state.fontFamily || 'Inter';
                controls.bgColor.value = state.backgroundColor || '#ffffff';
                controls.bgOpacity.value = state.backgroundOpacity || 1;
                controls.gradientColor1.value = state.gradientColor1 || '#a5b4fc';
                controls.gradientColor2.value = state.gradientColor2 || '#e0e7ff';
                controls.gradientAngle.value = state.gradientAngle || 145;
                
                // 更新背景类型
                currentBgType = state.backgroundType || 'solid';
                if (currentBgType === 'gradient') {
                    controls.bgTypeGradient.checked = true;
                    controls.bgTypeSolid.checked = false;
                    controls.solidBgControls.classList.add('hidden');
                    controls.gradientBgControls.classList.remove('hidden');
                    controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                    controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                } else {
                    controls.bgTypeSolid.checked = true;
                    controls.bgTypeGradient.checked = false;
                    controls.solidBgControls.classList.remove('hidden');
                    controls.gradientBgControls.classList.add('hidden');
                    controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                    controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                }
                
                // 更新值显示标签
                controls.borderWidthValue.textContent = `${controls.borderWidth.value}px`;
                controls.borderRadiusValue.textContent = `${controls.borderRadius.value}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
                
                // 更新文本内容
                const defaultText = currentBubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                controls.bubbleText.value = defaultText;
                const targetTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                targetTextContent.textContent = defaultText;
                
                // 恢复贴纸状态
                if (state.stickers && state.stickers.length > 0) {
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                    
                    // 清除当前的所有贴纸
                    targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                        wrapper.remove();
                    });
                    
                    // 恢复保存的贴纸
                    state.stickers.forEach(async (stickerData) => {
                        if (stickerData.fileId && fileStorageManager) {
                            try {
                                const imageUrl = await fileStorageManager.createFileURL(stickerData.fileId);
                                
                                const stickerWrapper = document.createElement('div');
                                stickerWrapper.className = 'sticker-wrapper';
                                stickerWrapper.dataset.id = stickerData.id;
                                stickerWrapper.style.position = 'absolute';
                                stickerWrapper.style.left = `${stickerData.left}px`;
                                stickerWrapper.style.top = `${stickerData.top}px`;
                                stickerWrapper.style.width = `${stickerData.width}px`;
                                stickerWrapper.style.height = `${stickerData.height}px`;
                                stickerWrapper.style.zIndex = stickerData.zIndex || 1;
                                stickerWrapper.style.cursor = 'move';
                                
                                const img = document.createElement('img');
                                img.src = imageUrl;
                                img.className = 'sticker-image';
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'contain';
                                img.style.userSelect = 'none';
                                img.style.pointerEvents = 'none';
                                
                                stickerWrapper.appendChild(img);
                                targetBubble.appendChild(stickerWrapper);
                                
                                // 使贴纸可拖拽
                                makeStickerDraggable(stickerWrapper);
                                
                            } catch (error) {
                                console.warn('恢复贴纸失败:', error, stickerData);
                            }
                        }
                    });
                }
                
                console.log(`已应用UI状态到${currentBubbleType}: backgroundType=${currentBgType}, stickers=${state.stickers?.length || 0}`);
            }
            let availableThemes = ['default'];

            // 加载所有可用主题
            async function loadAvailableThemes() {
                try {
                    if (!db) return;
                    
                    const transaction = db.transaction(['themeConfig'], 'readonly');
                    const store = transaction.objectStore('themeConfig');
                    
                    return new Promise((resolve) => {
                        const themes = ['default']; // 默认主题始终存在
                        const request = store.openCursor();
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                const key = cursor.key;
                                // 查找自定义主题（以theme_开头的键）
                                if (typeof key === 'string' && key.startsWith('theme_')) {
                                    const themeName = key.substring(6); // 移除'theme_'前缀
                                    themes.push(themeName);
                                }
                                cursor.continue();
                            } else {
                                availableThemes = themes;
                                resolve(themes);
                            }
                        };
                        
                        request.onerror = () => {
                            resolve(['default']);
                        };
                    });
                } catch (e) {
                    console.error('加载主题列表失败:', e);
                    return ['default'];
                }
            }

            // 更新主题选择下拉菜单
            function updateThemeSelector() {
                controls.themeSelect.innerHTML = '';
                
                availableThemes.forEach(themeName => {
                    const option = document.createElement('option');
                    option.value = themeName;
                    option.textContent = themeName === 'default' ? '默认主题' : themeName;
                    if (themeName === currentThemeName) {
                        option.selected = true;
                    }
                    controls.themeSelect.appendChild(option);
                });
                
                // 更新删除按钮状态
                controls.deleteThemeBtn.disabled = currentThemeName === 'default';
                controls.deleteThemeBtn.style.opacity = currentThemeName === 'default' ? '0.3' : '1';
                
                controls.renameThemeBtn.disabled = currentThemeName === 'default';
                controls.renameThemeBtn.style.opacity = currentThemeName === 'default' ? '0.3' : '1';
            }

            // 基于默认主题创建新主题
            async function createNewTheme() {
                const themeName = prompt('请输入新主题的名称:');
                if (!themeName || themeName.trim() === '') {
                    return;
                }
                
                const cleanThemeName = themeName.trim();
                if (cleanThemeName === 'default') {
                    showToast('不能使用"default"作为主题名称', 'error');
                    return;
                }
                
                if (availableThemes.includes(cleanThemeName)) {
                    if (!confirm(`主题"${cleanThemeName}"已存在，是否覆盖？`)) {
                        return;
                    }
                }
                
                try {
                    // 基于默认主题配置创建新主题
                    const themeData = {
                        type: `theme_${cleanThemeName}`,
                        name: cleanThemeName,
                        createdAt: new Date().toISOString(),
                        bubbleStyles: {
                            self: { ...DEFAULT_THEME_CONFIG.self },
                            kare: { ...DEFAULT_THEME_CONFIG.kare }
                        },
                        stickerLibrary: []  // 新主题不包含贴纸
                    };
                    
                    // 保存到数据库
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(themeData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // 更新主题列表和当前主题
                    if (!availableThemes.includes(cleanThemeName)) {
                        availableThemes.push(cleanThemeName);
                    }
                    currentThemeName = cleanThemeName;
                    updateThemeSelector();
                    
                    // 自动切换到新创建的主题
                    await loadTheme(cleanThemeName);
                    
                    showToast(`已基于默认主题创建"${cleanThemeName}"！`, 'success');
                    
                } catch (e) {
                    console.error('创建主题失败:', e);
                    showToast('创建主题失败: ' + e.message, 'error');
                }
            }

            
            // 检测用户当前应用的主题
            async function detectCurrentActiveTheme() {
                try {
                    // 从themeConfig读取当前生效的配置
                    const currentSelfConfig = await loadBubbleStyleConfig('bubbleStyleSelf');
                    const currentKareConfig = await loadBubbleStyleConfig('bubbleStyle');
                    
                    if (!currentSelfConfig && !currentKareConfig) {
                        // 如果没有配置，返回默认主题
                        return 'default';
                    }
                    
                    // 检查是否匹配默认主题
                    if (configMatches(currentSelfConfig, DEFAULT_THEME_CONFIG.self) && 
                        configMatches(currentKareConfig, DEFAULT_THEME_CONFIG.kare)) {
                        return 'default';
                    }
                    
                    // 检查是否匹配某个自定义主题
                    for (const themeName of availableThemes) {
                        if (themeName === 'default') continue;
                        
                        const themeData = await loadThemeData(themeName);
                        if (themeData && themeData.bubbleStyles) {
                            if (configMatches(currentSelfConfig, themeData.bubbleStyles.self) && 
                                configMatches(currentKareConfig, themeData.bubbleStyles.kare)) {
                                return themeName;
                            }
                        }
                    }
                    
                    // 如果没有匹配的主题，返回默认主题
                    return 'default';
                } catch (error) {
                    console.warn('检测当前主题失败，使用默认主题:', error);
                    return 'default';
                }
            }
            
            // 配置匹配检查（简化比较主要字段）
            function configMatches(config1, config2) {
                if (!config1 || !config2) return false;
                
                const keyFields = ['borderWidth', 'borderColor', 'backgroundColor', 'backgroundType', 'textColor'];
                return keyFields.every(field => config1[field] === config2[field]);
            }
            
            // 加载主题数据
            async function loadThemeData(themeName) {
                try {
                    const transaction = db.transaction(['themeConfig'], 'readonly');
                    const store = transaction.objectStore('themeConfig');
                    
                    return await new Promise((resolve, reject) => {
                        const request = store.get(`theme_${themeName}`);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error(`加载主题数据失败: ${themeName}`, error);
                    return null;
                }
            }
            
            // 直接应用配置到UI控件（用于默认主题显示）
            async function applyConfigToUI(bubbleType, config) {
                const originalBubbleType = currentBubbleType;
                
                // 临时切换到指定气泡类型
                currentBubbleType = bubbleType;
                
                // 应用配置到UI控件
                if (config) {
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = config.borderColor || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = config.textColor || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    controls.bgColor.value = config.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = config.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = config.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // 设置背景类型
                    currentBgType = config.backgroundType || 'solid';
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.checked = true;
                        controls.bgTypeSolid.checked = false;
                        controls.solidBgControls.classList.add('hidden');
                        controls.gradientBgControls.classList.remove('hidden');
                        // 更新按钮样式
                        controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    } else {
                        controls.bgTypeSolid.checked = true;
                        controls.bgTypeGradient.checked = false;
                        controls.solidBgControls.classList.remove('hidden');
                        controls.gradientBgControls.classList.add('hidden');
                        // 更新按钮样式
                        controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    }
                    
                    // 更新值显示标签
                    controls.borderWidthValue.textContent = `${config.borderWidth || 1}px`;
                    controls.borderRadiusValue.textContent = `${config.borderRadius || 12}px`;
                    controls.bgOpacityValue.textContent = `${Math.round((config.backgroundOpacity || 1) * 100)}%`;
                    controls.gradientAngleValue.textContent = `${config.gradientAngle || 145}deg`;
                    
                    // 设置文本内容
                    const defaultText = bubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    
                    // 更新气泡样式
                    updateBubbleStyle();
                }
                
                // 恢复原始气泡类型
                currentBubbleType = originalBubbleType;
            }
            
            // 更新主题UI状态
            function updateThemeUIState() {
                const isDefaultTheme = currentThemeName === 'default';
                
                if (isDefaultTheme) {
                    // 显示默认主题提示
                    controls.defaultThemeNotice.classList.remove('hidden');
                    
                    // 禁用所有编辑控件
                    const editControls = [
                        controls.borderWidth, controls.borderColor, controls.borderRadius,
                        controls.textColor, controls.fontFamily, controls.bgColor, controls.bgOpacity,
                        controls.gradientColor1, controls.gradientColor2, controls.gradientAngle,
                        controls.bgTypeSolid, controls.bgTypeGradient, controls.bubbleText
                    ];
                    
                    editControls.forEach(control => {
                        if (control) {
                            control.disabled = true;
                            control.style.opacity = '0.5';
                        }
                    });
                    
                    // 禁用保存按钮，但保持应用按钮可用
                    controls.saveOnlyBtn.disabled = true;
                    controls.saveOnlyBtn.style.opacity = '0.5';
                    // generateCodeBtn (保存并应用) 保持可用，因为用户可以应用默认主题
                    controls.generateCodeBtn.disabled = false;
                    controls.generateCodeBtn.style.opacity = '1';
                } else {
                    // 隐藏默认主题提示
                    controls.defaultThemeNotice.classList.add('hidden');
                    
                    // 启用所有编辑控件
                    const editControls = [
                        controls.borderWidth, controls.borderColor, controls.borderRadius,
                        controls.textColor, controls.fontFamily, controls.bgColor, controls.bgOpacity,
                        controls.gradientColor1, controls.gradientColor2, controls.gradientAngle,
                        controls.bgTypeSolid, controls.bgTypeGradient, controls.bubbleText
                    ];
                    
                    editControls.forEach(control => {
                        if (control) {
                            control.disabled = false;
                            control.style.opacity = '1';
                        }
                    });
                    
                    // 启用保存按钮
                    controls.saveOnlyBtn.disabled = false;
                    controls.generateCodeBtn.disabled = false;
                    controls.saveOnlyBtn.style.opacity = '1';
                    controls.generateCodeBtn.style.opacity = '1';
                }
                
                console.log(`主题UI状态已更新: ${currentThemeName} (锁定: ${isDefaultTheme})`);
            }
            // 加载指定主题
            async function loadTheme(themeName) {
                try {
                    console.log(`开始加载主题: ${themeName}`);
                    
                    if (themeName === 'default') {
                        // 加载固定的默认主题配置
                        currentThemeName = 'default';
                        
                        // 使用固定的默认配置（不从数据库读取）
                        const defaultSelfConfig = DEFAULT_THEME_CONFIG.self;
                        const defaultKareConfig = DEFAULT_THEME_CONFIG.kare;
                        
                        // 清空UI缓存
                        uiStateCache = { self: null, kare: null };
                        
                        // 临时保存当前气泡类型
                        const originalBubbleType = currentBubbleType;
                        
                        // 先应用self配置到UI并更新预览
                        currentBubbleType = 'self';
                        await applyConfigToUI('self', defaultSelfConfig);
                        updateBubbleStyle();
                        
                        // 再应用kare配置到UI并更新预览
                        currentBubbleType = 'kare';
                        await applyConfigToUI('kare', defaultKareConfig);
                        updateBubbleStyle();
                        
                        // 恢复原来的气泡类型
                        currentBubbleType = originalBubbleType;
                        
                        showToast('已切换到默认主题（只读模式）', 'info');
                    } else {
                        // 加载自定义主题
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        
                        const themeData = await new Promise((resolve, reject) => {
                            const request = store.get(`theme_${themeName}`);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        console.log('主题数据:', JSON.stringify({
                            name: themeName,
                            hasBubbleStyles: !!themeData?.bubbleStyles,
                            selfStyle: themeData?.bubbleStyles?.self ? {
                                backgroundType: themeData.bubbleStyles.self.backgroundType,
                                gradientColor1: themeData.bubbleStyles.self.gradientColor1,
                                gradientColor2: themeData.bubbleStyles.self.gradientColor2
                            } : null,
                            kareStyle: themeData?.bubbleStyles?.kare ? {
                                backgroundType: themeData.bubbleStyles.kare.backgroundType,
                                gradientColor1: themeData.bubbleStyles.kare.gradientColor1,
                                gradientColor2: themeData.bubbleStyles.kare.gradientColor2
                            } : null
                        }, null, 2));
                        
                        if (themeData && themeData.bubbleStyles && 
                            (themeData.bubbleStyles.self || themeData.bubbleStyles.kare)) {
                            
                            // 临时保存主题数据到工作位置（只保存有效配置）
                            if (themeData.bubbleStyles.self && Object.keys(themeData.bubbleStyles.self).length > 0) {
                                await saveBubbleStyleConfig(themeData.bubbleStyles.self, 'bubbleStyleSelf');
                                console.log('主题self配置已保存到工作区');
                            }
                            if (themeData.bubbleStyles.kare && Object.keys(themeData.bubbleStyles.kare).length > 0) {
                                await saveBubbleStyleConfig(themeData.bubbleStyles.kare, 'bubbleStyle');
                                console.log('主题kare配置已保存到工作区');
                            }
                            
                                
                            currentThemeName = themeName;
                            
                            // 清空UI缓存，强制重新加载
                            uiStateCache = { self: null, kare: null };
                            
                            // 同时初始化双方的UI状态缓存
                            const tempBubbleType = currentBubbleType;
                            
                            // 加载self配置到缓存
                            currentBubbleType = 'self';
                            await loadBubbleTypeSettings('self');
                            uiStateCache.self = captureCurrentUIState();
                            console.log(`主题"${themeName}"的self配置已缓存`);
                            
                            // 加载kare配置到缓存
                            currentBubbleType = 'kare';
                            await loadBubbleTypeSettings('kare');
                            uiStateCache.kare = captureCurrentUIState();
                            console.log(`主题"${themeName}"的kare配置已缓存`);
                            
                            // 恢复到原来的角色并应用状态
                            currentBubbleType = tempBubbleType;
                            applyUIState(uiStateCache[currentBubbleType]);
                            updateBubbleStyle();
                            
                            console.log(`主题"${themeName}"加载完成，双方配置已缓存`);
                            
                            showToast(`主题"${themeName}"已加载`, 'success');
                        } else {
                            throw new Error('主题数据不存在或损坏');
                        }
                    }
                    
                    // 更新主题UI状态（锁定/解锁控件）
                    updateThemeUIState();
                    updateThemeSelector();
                    
                } catch (e) {
                    console.error('加载主题失败:', e);
                    showToast('加载主题失败: ' + e.message, 'error');
                }
            }

            // 删除主题
            async function deleteTheme(themeName) {
                if (themeName === 'default') {
                    showToast('不能删除默认主题', 'error');
                    return;
                }
                
                if (!confirm(`确定要删除主题"${themeName}"吗？此操作不可恢复。`)) {
                    return;
                }
                
                try {
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(`theme_${themeName}`);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // 更新主题列表
                    availableThemes = availableThemes.filter(t => t !== themeName);
                    
                    // 如果删除的是当前主题，切换到默认主题
                    if (currentThemeName === themeName) {
                        currentThemeName = 'default';
                        await loadTheme('default');
                    }
                    
                    updateThemeSelector();
                    showToast(`主题"${themeName}"删除成功！`, 'success');
                    
                } catch (e) {
                    console.error('删除主题失败:', e);
                    showToast('删除主题失败: ' + e.message, 'error');
                }
            }

            // 重命名主题
            async function renameTheme(oldThemeName) {
                if (oldThemeName === 'default') {
                    showToast('不能重命名默认主题', 'error');
                    return;
                }
                
                const newName = prompt('请输入新的主题名称:', oldThemeName);
                if (!newName || newName.trim() === '') {
                    return;
                }
                
                const cleanNewName = newName.trim();
                if (cleanNewName === oldThemeName) {
                    return;
                }
                
                if (cleanNewName === 'default') {
                    showToast('不能使用"default"作为主题名称', 'error');
                    return;
                }
                
                if (availableThemes.includes(cleanNewName)) {
                    showToast(`主题名称"${cleanNewName}"已存在`, 'error');
                    return;
                }
                
                try {
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 读取旧主题数据
                    const oldData = await new Promise((resolve, reject) => {
                        const request = store.get(`theme_${oldThemeName}`);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (!oldData) {
                        showToast('主题数据不存在', 'error');
                        return;
                    }
                    
                    // 删除旧主题
                    await new Promise((resolve, reject) => {
                        const request = store.delete(`theme_${oldThemeName}`);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // 创建新主题数据（保持原有的数据和ID）
                    const newData = {
                        ...oldData,
                        type: `theme_${cleanNewName}`,
                        name: cleanNewName,
                        renamedFrom: oldThemeName,
                        renamedAt: new Date().toISOString()
                    };
                    
                    // 保存新主题
                    await new Promise((resolve, reject) => {
                        const request = store.put(newData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // 更新主题列表
                    const index = availableThemes.indexOf(oldThemeName);
                    if (index > -1) {
                        availableThemes[index] = cleanNewName;
                    }
                    
                    // 如果当前主题是被重命名的主题，更新当前主题名称
                    if (currentThemeName === oldThemeName) {
                        currentThemeName = cleanNewName;
                    }
                    
                    updateThemeSelector();
                    showToast(`主题已重命名为"${cleanNewName}"`, 'success');
                    
                } catch (e) {
                    console.error('重命名主题失败:', e);
                    showToast('重命名失败: ' + e.message, 'error');
                }
            }

            // ==================== 主题导入导出功能 ====================
            
            // 检查是否有未保存的更改
            function hasUnsavedChanges() {
                // 简单实现：检查当前界面配置是否与数据库中保存的配置一致
                // 这里可以根据需要实现更精确的检查逻辑
                return false; // 暂时返回false，后续可以完善
            }

            // 显示提示消息
            function showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type === 'error' ? 'bg-red-500' : type === 'success' ? 'bg-green-500' : 'bg-blue-500'} text-white px-4 py-2 rounded-lg fixed top-4 right-4 z-[9999]`;
                toast.style.display = 'block';
                
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 3000);
            }

            // 导出主题功能
            async function exportBubbleTheme() {
                try {
                    showToast('正在导出主题，请稍候...', 'info');
                    
                    // 1. 收集样式配置
                    const bubbleStyleSelf = await loadBubbleStyleConfig('bubbleStyleSelf');
                    const bubbleStyleKare = await loadBubbleStyleConfig('bubbleStyle');
                    
                    // 2. 收集贴纸库数据
                    await loadStickerLibraryFromStorage();
                    
                    // 3. 创建导出配置
                    const exportConfig = {
                        version: "1.0",
                        exportTime: new Date().toISOString(),
                        themeName: currentThemeName === 'default' ? 'ExportedTheme' : currentThemeName,
                        bubbleStyles: {
                            self: bubbleStyleSelf || null,
                            kare: bubbleStyleKare || null
                        },
                        stickerLibrary: stickerLibrary || []
                    };

                    // 4. 创建zip文件
                    const zip = new JSZip();
                    
                    // 添加配置文件
                    zip.file('config.json', JSON.stringify(exportConfig, null, 2));
                    
                    // 添加清单文件
                    const manifest = {
                        version: "1.0",
                        createdAt: new Date().toISOString(),
                        totalStickers: stickerLibrary.length,
                        hasStyles: {
                            self: !!bubbleStyleSelf,
                            kare: !!bubbleStyleKare
                        }
                    };
                    zip.file('manifest.json', JSON.stringify(manifest, null, 2));
                    
                    // 5. 添加贴纸文件
                    const stickerFolder = zip.folder('stickers');
                    const stickerFileMapping = {};
                    
                    for (let i = 0; i < stickerLibrary.length; i++) {
                        const sticker = stickerLibrary[i];
                        try {
                            if (sticker.fileId && fileStorageManager) {
                                // 获取文件记录
                                const fileRecord = await fileStorageManager.getFile(sticker.fileId);
                                if (fileRecord && fileRecord.blob) {
                                    // 生成文件名：保持原扩展名
                                    const ext = sticker.originalName ? 
                                        sticker.originalName.split('.').pop() : 
                                        (sticker.fileType === 'image/svg+xml' ? 'svg' : 'png');
                                    const fileName = `${sticker.fileId}.${ext}`;
                                    
                                    stickerFolder.file(fileName, fileRecord.blob);
                                    stickerFileMapping[sticker.id] = fileName;
                                }
                            }
                        } catch (error) {
                            console.warn(`导出贴纸 ${sticker.id} 失败:`, error);
                        }
                    }
                    
                    // 更新配置中的文件映射
                    exportConfig.stickerFileMapping = stickerFileMapping;
                    zip.file('config.json', JSON.stringify(exportConfig, null, 2));
                    
                    // 6. 生成并下载zip文件
                    const zipBlob = await zip.generateAsync({type: 'blob'});
                    const url = URL.createObjectURL(zipBlob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `bubble-theme-${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('主题导出成功！', 'success');
                    
                } catch (error) {
                    console.error('导出主题失败:', error);
                    showToast('导出失败: ' + error.message, 'error');
                }
            }

            // 导入主题功能
            async function importBubbleTheme(zipFile) {
                try {
                    showToast('正在导入主题，请稍候...', 'info');
                    
                    // 1. 解析zip文件
                    const zip = await JSZip.loadAsync(zipFile);
                    
                    // 2. 读取和验证配置文件
                    const configFile = zip.file('config.json');
                    if (!configFile) {
                        throw new Error('主题包缺少配置文件');
                    }
                    
                    const configText = await configFile.async('text');
                    const config = JSON.parse(configText);
                    
                    if (!config.version) {
                        throw new Error('无效的主题包格式');
                    }
                    
                    // 3. 询问用户是否要应用配置
                    const stickerCount = config.stickerLibrary?.length || 0;
                    const hasStyles = config.bubbleStyles?.self || config.bubbleStyles?.kare;
                    
                    let message = `即将导入包含 ${stickerCount} 个贴纸`;
                    if (hasStyles) {
                        message += ' 和气泡样式配置';
                    }
                    message += ' 的主题包。\n\n';
                    
                    if (stickerLibrary.length > 0) {
                        message += '检测到现有贴纸库，如发现重名文件将询问您的处理方式。\n\n';
                    }
                    
                    message += '是否继续导入？';
                    
                    if (!confirm(message)) {
                        return;
                    }
                    
                    // 4. 导入贴纸文件
                    const newStickerLibrary = [];
                    const nameConflicts = [];
                    
                    if (config.stickerLibrary && config.stickerLibrary.length > 0) {
                        const stickerFolder = zip.folder('stickers');
                        
                        for (const stickerConfig of config.stickerLibrary) {
                            try {
                                const fileName = config.stickerFileMapping?.[stickerConfig.id];
                                if (!fileName) continue;
                                
                                const stickerFile = stickerFolder.file(fileName);
                                if (!stickerFile) continue;
                                
                                // 检查文件名冲突
                                let finalName = stickerConfig.originalName;
                                const existingSticker = stickerLibrary.find(s => s.originalName === finalName);
                                
                                if (existingSticker) {
                                    const action = confirm(`发现重名文件 "${finalName}"。\n\n点击"确定"覆盖现有文件\n点击"取消"保留两个文件（新文件将重命名）`);
                                    
                                    if (!action) {
                                        // 重命名新文件
                                        const nameParts = finalName.split('.');
                                        const ext = nameParts.pop();
                                        const baseName = nameParts.join('.');
                                        finalName = `${baseName}(1).${ext}`;
                                    } else {
                                        // 删除现有文件
                                        await deleteSticker(existingSticker.id);
                                    }
                                }
                                
                                // 获取文件数据并存储
                                const fileBlob = await stickerFile.async('blob');
                                const newStickerId = 'sticker_import_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                                
                                if (fileStorageManager) {
                                    // 存储到文件系统
                                    const storeResult = await fileStorageManager.storeFile(fileBlob, {
                                        category: 'bubble_sticker',
                                        originalName: finalName
                                    });
                                    
                                    // 创建文件引用
                                    await fileStorageManager.createFileReference(
                                        storeResult.fileId,
                                        'bubble_sticker',
                                        newStickerId
                                    );
                                    
                                    // 添加到贴纸库
                                    const newSticker = {
                                        id: newStickerId,
                                        fileId: storeResult.fileId,
                                        originalName: finalName,
                                        fileType: storeResult.type,
                                        size: storeResult.size
                                    };
                                    
                                    newStickerLibrary.push(newSticker);
                                    stickerLibrary.push(newSticker);
                                }
                                
                            } catch (error) {
                                console.warn(`导入贴纸失败:`, error);
                            }
                        }
                    }
                    
                    // 5. 保存更新后的贴纸库
                    await saveStickerLibraryToStorage();
                    await renderStickerLibrary();
                    
                    // 6. 直接保存为新主题
                    if (config.bubbleStyles?.self || config.bubbleStyles?.kare) {
                        // 保存为新主题，自动添加"【导入】"后缀
                        let baseThemeName = config.themeName || '导入主题';
                        let importedThemeName = `${baseThemeName}【导入】`;
                        let counter = 1;
                        let finalThemeName = importedThemeName;
                        
                        // 确保主题名称不重复
                        while (availableThemes.includes(finalThemeName)) {
                            finalThemeName = `${importedThemeName}_${counter}`;
                            counter++;
                        }
                        
                        const themeData = {
                            type: `theme_${finalThemeName}`,
                            name: finalThemeName,
                            createdAt: new Date().toISOString(),
                            bubbleStyles: config.bubbleStyles,
                            stickerLibrary: newStickerLibrary
                        };
                        
                        // 保存主题到数据库
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        await new Promise((resolve, reject) => {
                            const request = store.put(themeData);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        
                        // 更新主题列表
                        availableThemes.push(finalThemeName);
                        updateThemeSelector();
                        
                        // 自动切换到新导入的主题
                        currentThemeName = finalThemeName;
                        await loadTheme(finalThemeName);
                        
                        showToast(`主题已导入并保存为"${finalThemeName}"`, 'success');
                    }
                    else {
                        showToast(`成功导入 ${newStickerLibrary.length} 个贴纸！`, 'success');
                    }
                    
                } catch (error) {
                    console.error('导入主题失败:', error);
                    showToast('导入失败: ' + error.message, 'error');
                }
            }

            // 多主题管理事件监听器
            controls.themeSelect.addEventListener('change', async (e) => {
                const selectedTheme = e.target.value;
                if (selectedTheme !== currentThemeName) {
                    await loadTheme(selectedTheme);
                }
            });

            controls.createNewThemeBtn.addEventListener('click', createNewTheme);

            controls.renameThemeBtn.addEventListener('click', async () => {
                await renameTheme(currentThemeName);
            });

            controls.deleteThemeBtn.addEventListener('click', async () => {
                await deleteTheme(currentThemeName);
            });

            // 导入导出事件监听器
            controls.exportThemeBtn.addEventListener('click', async () => {
                // 检查是否有未保存的更改
                if (hasUnsavedChanges()) {
                    const save = confirm('检测到未保存的更改。是否先保存当前配置？\n\n点击"确定"保存并导出\n点击"取消"放弃更改并导出');
                    if (save) {
                        // 触发保存按钮
                        controls.generateCodeBtn.click();
                        // 等待保存完成
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                await exportBubbleTheme();
            });

            controls.importThemeFile.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && file.name.endsWith('.zip')) {
                    await importBubbleTheme(file);
                } else if (file) {
                    showToast('请选择.zip格式的主题包文件', 'error');
                }
                // 重置文件输入
                e.target.value = '';
            });
            
            initializeApp();
        });
    </script>
</body>
</html>